{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to Alamgir Book <p>Learning Book : Learn, practice, code, and document programming topics.</p>"},{"location":"engineering-fundamentals/framework/","title":"Framework","text":"<p>A pre-built structure or platform that provides reusable code, tools, and best practices to speed up application development.</p> <p>Characteristics:</p> <ol> <li>Ready-made solutions.</li> <li>Advanced solutions over the programming language.</li> <li>Provides solutions to existing problems of a programming language.</li> <li>Always built on top of the existing programming language.</li> </ol>"},{"location":"engineering-fundamentals/jar-vs-war/","title":"2. JAR vs WAR","text":"JAR vs WAR  <ol> <li> <p>Full Form:</p> <ul> <li>JAR = Java ARchive</li> <li>WAR = Web ARchive</li> </ul> </li> <li> <p>Purpose</p> <ul> <li>JAR = Standalone Java apps or libraries</li> <li>WAR = Web applications for servers</li> </ul> </li> <li> <p>Contents</p> <ul> <li>JAR = .class files, resources, META-INF</li> <li>WAR = Web files (HTML/JSP), WEB-INF, classes, libraries</li> </ul> </li> <li> <p>Deployment:</p> <ul> <li>JAR = Run with java -jar</li> <li>WAR = Deploy on web server (Tomcat, JBoss)</li> </ul> </li> <li> <p>Execution:</p> <ul> <li>JAR = Executable (if Main-Class present)</li> <li>WAR = Server-managed, not directly executable</li> </ul> </li> <li> <p>Scope:</p> <ul> <li>JAR = Desktop/CLI apps, libraries</li> <li>WAR = Web apps (servlets, JSP, REST APIs)</li> </ul> </li> <li> <p>Relationship:</p> <ul> <li>WAR often contains JARs inside WEB-INF/lib.</li> <li>JAR = Java app/library</li> <li>WAR = Web app for server</li> </ul> </li> </ol>"},{"location":"engineering-fundamentals/maven-vs-gradle/","title":"3. Maven vs Gradle","text":"Maven vs Gradle Comparison <ol> <li> <p>Build Tool Type</p> <ul> <li>Maven: XML-based build tool.</li> <li>Gradle: Groovy/Kotlin DSL-based build tool.</li> </ul> </li> <li> <p>Configuration</p> <ul> <li>Maven: Declarative (pom.xml), describe what to do.</li> <li>Gradle: Declarative + imperative (build.gradle), describe what and how.</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Maven: Slower, full build each time.</li> <li>Gradle: Faster, supports incremental builds and caching.</li> </ul> </li> <li> <p>Dependency Management</p> <ul> <li>Maven: Centralized pom.xml dependencies.</li> <li>Gradle: Flexible, supports dynamic dependencies, Maven &amp; Ivy repos.</li> </ul> </li> <li> <p>Flexibility</p> <ul> <li>Maven: Less flexible, relies on plugins.</li> <li>Gradle: Highly flexible, supports custom tasks.</li> </ul> </li> <li> <p>Popularity</p> <ul> <li>Maven: Widely used in enterprise, stable.</li> <li>Gradle: Popular in modern Java, Android, multi-language projects.</li> </ul> </li> <li> <p>Learning Curve</p> <ul> <li>Maven: Easier for beginners.</li> <li>Gradle: Steeper learning curve, scriptable.</li> </ul> </li> </ol> <p>Maven = simpler, convention-based, slower Gradle = faster, flexible, modern</p>"},{"location":"engineering-fundamentals/microservice-architecture/","title":"4. Microservice Architecture","text":"Microservice Architecture <p>An application split into small, independent services, each handling a specific business function.</p> <p>Characteristics</p> <ul> <li>Separate deployable units</li> <li>Communicate via APIs</li> <li>Independently scalable &amp; maintainable.</li> <li>Flexible but more complex</li> <li>Not a Framework,this is a achitecture of building an application.</li> </ul>"},{"location":"engineering-fundamentals/monolithic-architecture/","title":"5. Monolithic Architecture","text":"Monolithic Architecture <p>One unified application with all components (UI, logic, data) bundled together.</p> <p>Characteristics</p> <ul> <li>Single deployable unit (JAR/WAR)</li> <li>Easy to build at start, complex as it grows</li> <li>Difficult to maintain and scale parts independently</li> </ul>"},{"location":"engineering-fundamentals/uuid/","title":"6. UUID","text":"UUID - Universally Unique Identifier <p>A UUID (Universally Unique Identifier) is a nearly unique 128-bit value that can identify objects across different systems or datasets, functioning like a digital fingerprint, and does not follow a sequential order.</p>"},{"location":"engineering-fundamentals/uuid/#1-uuid-structure","title":"1. UUID Structure","text":"<ul> <li>128-bit value represented as 32 hexadecimal characters.</li> <li>Often displayed in five groups: <code>8-4-4-4-12</code> with hyphens.</li> <li>Hyphens are optional, included for readability and historical reasons.</li> <li>Example: <code>67e55044-10b1-426f-9247-bb680e5fe0c8</code></li> </ul>"},{"location":"engineering-fundamentals/uuid/#2-uuid-variants","title":"2. UUID Variants","text":"<ul> <li>Variant 0: Obsolete</li> <li>Variant 1: Main variant used today</li> <li>Variant 2: Reserved for Microsoft backward compatibility</li> </ul>"},{"location":"engineering-fundamentals/uuid/#3-uuid-versions","title":"3. UUID Versions","text":"<ul> <li> <p>v1: Time and MAC address based; unique but reveals creation time/location.</p> </li> <li> <p>Structure: <code>time_low</code>, <code>time_mid</code>, <code>time_high_and_version</code>, <code>clock_seq_and_version</code>, <code>node</code></p> </li> <li>v2: POSIX UID replaces low_time; rarely used due to higher collision risk.</li> <li>v3 &amp; v5: Name-based using namespace + name; v3 uses <code>MD5 hashing</code> algorithm, v5 uses <code>SHA1 hashing</code> algorithm.</li> <li>v4: Generated completly randomly and have no identifying information thus small chance of collision.</li> <li>v6: Like v1, but timestamp bits reordered (most significant first).</li> <li>v7: Time-based using Unix Epoch; node replaced with randomness for privacy.</li> <li>v8: Vendor-specific implementations following RFC rules; version indicated in third segment.</li> </ul> <p>A collision occurs when the same UUID is generated more than once and is assigned to different objects. </p>"},{"location":"engineering-fundamentals/uuid/#4-uuid-randomness-capacity","title":"4. UUID Randomness Capacity","text":"<ul> <li>A UUID is a 128-bit number.</li> <li> <p>Not all 128 bits are available for randomness:</p> <ul> <li>6 bits are reserved for version + variant.</li> <li>That leaves 122 random bits.</li> </ul> </li> <li> <p>So maximum unique random UUIDs = 2\u00d710\u00b2\u00b2 \u2248 5.3\u00d710\u00b3\u2076</p> </li> </ul>"},{"location":"engineering-fundamentals/uuid/#5-probability-of-collision-between-two-uuids","title":"5. Probability of Collision Between Two UUIDs","text":"<p>If we generate two UUIDs, the probability of them colliding is: 1 / 2\u00b9\u00b2\u00b2 \u2248 1.88 \u00d7 10\u207b\u00b3\u2077</p> <p>which is extremly small and therefore can be regarded as practically impossible .</p>"},{"location":"engineering-fundamentals/uuid/#6-how-many-uuid-needs-to-be-generated-to-get-a-collision-with-a-certain-probability","title":"6. How many UUID needs to be generated to get a collision with a certain probability ?","text":"<p>To calculate the number of UUIDs required for a collision with a given probability (p),  The Birthday Bound Formula is used: n = \u221a(2\u00b7N\u00b7ln(1 / (1 - p)))  </p> For a 10% probability of collision: <p>n = \u221a(2 \u00b7 2\u00b9\u00b2\u00b2 \u00b7 ln(1 / (1 - 0.1))) \u2248 1,058,482,487,574,424,704 \u00d7 10\u00b9\u2078 UUIDs</p> <p>Memory Requirements</p> <p>Storing all generated UUIDs (128 bits = 16 bytes each):</p> <ul> <li>Decimal: 16,935,719.80 TB (\u2248 17 million terabytes)</li> <li>Binary (TiB): 15,402,947.43 TiB</li> </ul> <p>Time to Generate</p> <p>At a rate of 1,000,000 UUIDs per second:</p> <ul> <li>Seconds required: \u2248 1.058 \u00d7 10\u00b9\u00b2</li> <li>Years required: 33,564.26 years</li> </ul> Key Points  <ul> <li>Collisions are theoretically possible.</li> <li>A 10% chance requires generating about (1.06 \u00d7 10\u00b9\u2078) UUIDs, needing ~17 million TB of storage and 33,564 years at 1M UUIDs/sec.</li> <li>so Collisions are practically impossible for real systems.</li> </ul>"},{"location":"engineering-fundamentals/uuid/#7-uuid-collision-handling","title":"7. UUID Collision Handling","text":"<ul> <li> <p>Local collisions: If a UUID field is UNIQUE, a duplicate insert will fail and would not be saved. Generating a new UUID resolves the issue.</p> </li> <li> <p>Global collisions: Extremely unlikely; collisions across different systems are virtually impossible.</p> </li> <li> <p>Merging datasets : UUIDs allow multiple sets to combine without remapping. Rare collisions during merging can be detected and handled like local collisions.</p> </li> </ul>"},{"location":"engineering-fundamentals/uuid/#8-integer-vs-uuid-storage-across-databases","title":"8. Integer vs UUID Storage Across Databases","text":"<ul> <li> <p>Storage size per value:</p> <ul> <li>Auto-incrementing integer: 32 bits (4 bytes)</li> <li>UUID (binary): 128 bits (16 bytes)</li> <li>UUID as CHAR(36): 288 bits (36 bytes)</li> </ul> </li> <li> <p>Best Practices for Using UUIDs</p> <ul> <li>Store UUIDs in a BINARY(16) column instead of CHAR(36) to reduce storage overhead.</li> </ul> </li> </ul>"},{"location":"engineering-fundamentals/uuid/#9-how-to-generate-a-uuid","title":"9. How to Generate a UUID","text":"Vendor Data Type for UUID Function to Generate UUID Oracle RAW(16) <code>SYS_GUID()</code> SQL Server UNIQUEIDENTIFIER <code>NEWID()</code> or <code>NEWSEQUENTIALID()</code> MySQL BINARY(16) or CHAR(36) <code>UUID()</code> or <code>UUID_TO_BIN(UUID())</code> PostgreSQL <code>uuid</code> <code>gen_random_uuid()</code> (requires <code>pgcrypto</code>)"},{"location":"engineering-fundamentals/uuid/#10-use-case-of-uuid","title":"10. Use Case of UUID","text":"<ul> <li>Decentralized generation: UUIDs can be generated anywhere (backend, client, database) and are reliably unique.</li> <li>Simplifies object identity: Maintains uniqueness across disconnected systems.</li> <li>Early ID assignment: Unlike auto-incrementing integers, UUIDs allow determining an object's ID before inserting into a database. </li> </ul> <p>\u2191 Back to top</p>"},{"location":"spring-boot/1-introduction/","title":"1. Introduction","text":"Why Spring Boot (over Spring) ? <ul> <li>Auto-config : less boilerplate, faster dev</li> <li>Embedded server : Tomcat/Jetty/Undertow, no external WAR deploy</li> <li>Actuator : monitoring &amp; health checks</li> <li>Defaults : simpler setup (convention over configuration)</li> <li>Microservices-ready : easier future scaling</li> <li>Starter dependencies : simplifies build config</li> <li>No XML/code generation : annotation &amp; Java-based config</li> </ul>"},{"location":"spring-boot/1-introduction/","title":"@SpringBootApplication","text":"<p><code>@SpringBootApplication</code> is a convenience annotation that combines three annotations :</p> <ul> <li><code>1. @SpringBootConfiguration</code> \u2013 Marks the class as a configuration class (like @Configuration).</li> <li><code>2. @EnableAutoConfiguration</code> \u2013 Enables Spring Boot\u2019s auto-configuration feature.</li> <li><code>3. @ComponentScan</code> \u2013 Tells Spring to scan the package (and sub-packages) for beans, components, controllers, services, etc.</li> </ul> <p>Key Points</p> <ul> <li>Must be placed on the main application class.</li> <li>Scans the package where it\u2019s located and all sub-packages.</li> <li>Enables Spring Boot auto-configuration, saving manual setup.    </li> </ul>"},{"location":"spring-boot/1-introduction/","title":"starter","text":"<ul> <li>Collection of Multiple Dependencies.</li> <li>Reduces boilerplate configuration \u2014 don\u2019t need to figure out which versions of libraries work together.</li> <li>Auto-configuration : works with Spring Boot\u2019s auto-config to set up defaults.</li> <li>Less version conflicts : Spring Boot manages dependency versions.</li> <li>Default Starter : spring-boot-starter</li> </ul> <p>Example: </p> <p>The Spring Boot Web Starter is:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>What it includes (behind the scenes):</p> <ul> <li>Spring MVC : for REST and web </li> <li>Jackson : for JSON handling</li> <li>Validation API (hibernate-validator) : for request validation</li> <li>Tomcat (embedded server, default)</li> </ul> <p>So by adding just this one starter, don\u2019t need to manually add each of those dependencies one by one.</p>"},{"location":"spring-boot/1-introduction/","title":"application.properties","text":"<ul> <li>Always configuring data which is commonly being used by all spring Beans.</li> <li>Called as Configuration file.</li> <li>key value pair format(key-val).</li> <li>two types of properties<ul> <li>pre-defiend(<code>spring.application.name</code>)</li> <li>used defiend(<code>db.name=alamgir</code>)</li> </ul> </li> </ul>"},{"location":"spring-boot/2-spring-runner/","title":"1. Command-Line Arguments","text":"<ul> <li>To take argument from command line or passing values to main method and access them using <ul> <li><code>CommandLineRunner</code></li> <li><code>ApplicationRunner</code></li> <li><code>SpringApplication.getRunArguments()</code></li> <li>or even with <code>@Value</code> injection</li> </ul> </li> <li>Example      <code>main(String[]args)</code> : passing values to main method via command line arguments.</li> </ul>"},{"location":"spring-boot/2-spring-runner/#com","title":"2. CommandLineRunner and ApplicationRunner","text":"<ul> <li>executed immediately after SpringApplication.run() completes.</li> <li>Having abstract method.</li> </ul> <p>Example: <pre><code>@SpringBootApplication\npublic static void main(String[] args) {\n    SpringApplication.run(MyApplication.class, args);\n    // Runners execute AFTER this\n}\n</code></pre></p>"},{"location":"spring-boot/2-spring-runner/#run","title":"3. Runner class","text":"<p>A component class that implements CommandLineRunner or ApplicationRunner and is registered as a Spring bean is called a Spring Boot runner class.</p> <p>Why is it called a Spring Boot runner class?</p> <p>beacuse such a class : </p> <ul> <li>Runs automatically at startup.</li> <li>Is a Spring-managed bean.</li> <li>Implements <code>CommandLineRunner</code> or <code>ApplicationRunner</code> to define startup logic</li> </ul> <p>Key Points</p> <ul> <li>impementing abstract method .</li> <li>Executed only once and run automatically.</li> <li>Executed logic which write inside implemented of Runner interface .</li> <li>used to define logic for loading configuration values, properties.</li> </ul> <p>Spring Boot application startup lifecycle</p> <ol> <li>Spring Boot App </li> <li>Start </li> <li>Run method<ul> <li>IoC Container </li> <li>Bean Object created</li> <li>Runners</li> <li>Started (Application is ready to use. perform operation)</li> </ul> </li> </ol> <p>How many Runners can we add in Spring Boot Application? </p> <p>Answer: Can add unlimited runner classes.</p> <p>Multiple Runner class Execution Order</p> <ol> <li>Execute randomly.</li> <li>Control execution order :using  <code>@Order</code> <p>least number : higher priority</p> </li> </ol> Example Code <pre><code>@Order(1) //executed  second\n@Component\npublic class FirstRunner implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"FirstRunner \");\n    }\n}\n\n@Order(-5) //executed  first\n@Component\npublic class SecondRunner implements ApplicationRunner {\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        System.out.println(\"SecondRunner\");\n    }\n}\n\n@Order(2) //executed  third\n@Component\npublic class ThirdRunner implements CommandLineRunner {\n    @Override\n    public void run(String... args) throws Exception {\n        System.out.println(\"ThirdRunner \");\n    }\n}\n</code></pre>"},{"location":"spring-boot/2-spring-runner/#dif","title":"4. Difference between CommandLineRunner and ApplicationRunner?","text":"<ol> <li> <p>CommandLineRunner</p> <ul> <li>Method : run(String... args)</li> <li>Argument Type : String of Array</li> <li>alamgirPassasArguemts -&gt; main(String[] args)-&gt; SpringApplication.run(MyApplication.class, args)-&gt;run(String... args)</li> <li>passing arguemt share the all Runners.</li> </ul> </li> <li> <p>ApplicationRunner</p> <ul> <li>Method : run(ApplicationArguments args)</li> <li>Argument Type : Object (ApplicationArguments)</li> <li>alamgirPassasArguemts -&gt; main(String[] args)-&gt; SpringApplication.run(MyApplication.class, args)-&gt; run(ApplicationArguments args)</li> </ul> </li> </ol> <p>\u2191 Back to top </p> <p>Github Code : Spring Runner : Spring Boot </p>"},{"location":"spring-boot/5-actuator/","title":"Spring Boot Actuator","text":"<p>pring Boot Actuator provides production-ready features to help  monitor and manage  application.</p>"},{"location":"spring-boot/5-actuator/#c","title":"1. Common  Actuator Endpoints","text":"<ul> <li><code>/actuator/health</code> \u2013 app health status</li> <li><code>/actuator/info</code> \u2013 shows app info (can include custom data)</li> <li><code>/actuator/metrics</code> \u2013 shows performance metrics</li> <li><code>/actuator/beans</code> \u2013 lists all configured beans</li> <li><code>/actuator/env</code> \u2013 shows environment properties</li> <li><code>/actuator/mappings</code> \u2013 lists all request mappings</li> <li><code>/actuator/shutdown</code> \u2013 gracefully shuts down the app</li> <li><code>/actuator/threaddump</code> \u2013 shows thread dump</li> </ul>"},{"location":"spring-boot/5-actuator/#e","title":"2. Enable by adding the dependency","text":"<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n    &lt;version&gt;3.5.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"spring-boot/5-actuator/#s","title":"3. Spring Actuator Endpoints Security","text":"<p>By default, only <code>/health</code> and <code>/info</code> are publicly accessible; all other Actuator endpoints require Spring Security configuration. Configure exposed endpoints in <code>application.properties</code></p> <pre><code># - enable all endpoints\nmanagement.endpoints.web.exposure.include=*\n\n# - enable all endpoints except beans\nmanagement.endpoints.web.exposure.exclude=beans\n\n\n# - enable only beans and health\nmanagement.endpoints.web.exposure.include=beans,health\n</code></pre>"},{"location":"spring-boot/5-actuator/#cu","title":"4. Customizing Actuator End Points Base Path","text":"<p>By default base-path of actuator endpoints is <code>/actuator</code>.We can change the default <code>/actuator</code> base path using:</p> <pre><code>management.endpoints.web.base-path=/management\n</code></pre>"},{"location":"spring-boot/5-actuator/#cus","title":"5. Spring Actuator Custom Endpoints","text":"<p>can be access through <code>actuator/myendpoint</code></p> <pre><code>@Endpoint(id = \"myendpoint\")\n@Component\npublic class CustomActuator {\n\n    @Bean\n    @ReadOperation\n    public String customActuatorMethod() {\n        return \"This is Custom Actuator Endpoint\";\n    }\n}\n</code></pre> <p>\u2191 Back to top </p>"},{"location":"spring-boot/6-yaml-vs-properties/","title":"Config Files: .properties vs .yml, Application vs Bootstrap","text":""},{"location":"spring-boot/6-yaml-vs-properties/#p","title":"1.  .properties vs .yml (YAML)","text":"Feature <code>.properties</code> <code>.yml</code> / <code>.yaml</code> Format Key-value pairs (<code>key=value</code>) Hierarchical (uses indentation):<code>key: value</code> Preferred for Simple configs Complex, nested configs Structure Sequential, non-nested Supports nested/hierarchical data Repetition Keys often repeated Reuses parent keys (no repetition) Multi-profile Needs separate files for each profile Multiple profiles in one file Priority between .properties and .yml  <p>If both <code>application.properties</code> and <code>application.yml</code> exist in the same location,Spring Boot gives priority to <code>application.properties</code></p> <p>application.yml</p> <p><code>yml server:     port: 8081</code></p> <p>application.properties</p> <p><pre><code>server.port=8088\n</code></pre>  Result: Port = 8088 (because <code>.properties</code> overrides <code>.yml</code>)</p>"},{"location":"spring-boot/6-yaml-vs-properties/#a","title":"2. application.properties / application.yml","text":"<ul> <li>Default configuration file for Spring Boot.</li> <li> <p>Used for:</p> <ul> <li>App-specific configs (DB, server, security)</li> <li>Profiles (<code>application-dev.yml</code>, etc.)</li> </ul> </li> <li> <p>Location: <code>src/main/resources/</code></p> </li> </ul>"},{"location":"spring-boot/6-yaml-vs-properties/#b","title":"3. bootstrap.properties / bootstrap.yml","text":"<ul> <li> <p>Used for:</p> <ul> <li>External config sources (e.g., Spring Cloud Config)</li> <li>Service discovery or environment setup</li> </ul> </li> <li> <p>Needed only when using Spring Cloud / Config Server.</p> </li> <li>Location: <code>src/main/resources/</code></li> </ul> Loading Order File Loaded Priority <code>bootstrap.yml / bootstrap.properties</code> First Lower <code>application.yml / application.properties</code> After Higher  Example bootstrap.ymlapplication.propertiesapplication.yml <pre><code>spring:\n  application:\n    name: my-service\n  cloud:\n    config:\n      uri: http://localhost:8888\n</code></pre> <pre><code>  server.port=8081\n  spring.datasource.url=jdbc:mysql://localhost:3306/test\n</code></pre> <pre><code>server:\n  port: 8081\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/test\n</code></pre> <p>\u2191 Back to top </p>"},{"location":"spring-boot/7-profiles/","title":"7. Spring Boot Profiles","text":""},{"location":"spring-boot/7-profiles/#top","title":"Spring Boot Profiles1. Spring Boot Profiles2. Defining Profiles3. Way of activating a Profile4. Profile File Loading Order5. Use Case","text":"<p>Profiles allow  to define different configurations for different environments (e.g., dev, test, prod,uat).</p> <p>create profile-specific files:</p> <ul> <li>application-dev.properties   : local development</li> <li>application-test.properties   : testing/staging</li> <li>application-prod.properties : production</li> <li>application-uat.properties     : User Acceptence Testing</li> </ul> <ul> <li>In application.properties: <code>spring.profiles.active=dev</code></li> <li>Command line: <code>--spring.profiles.active=dev</code></li> <li>Environment variable: <code>SPRING_PROFILES_ACTIVE=dev</code></li> </ul> <ul> <li><code>application.properties</code>: common config (base/default)</li> <li><code>application-{profile}.properties</code> : overrides base config when active</li> </ul> Example <p>application.properties <pre><code>spring.profiles.active=dev\nserver.port=8080\n</code></pre></p> <p>application-dev.properties <pre><code>server.port=8081\n</code></pre></p> <p>application-prod.properties <pre><code>server.port=8082\n</code></pre></p> <p>What happend?</p> <ul> <li>Active profile: dev </li> <li>Base config: application.properties \u2192 server.port=8080</li> <li>Profile-specific override: application-dev.properties \u2192 server.port=8081</li> <li>Result: server.port = 8081</li> </ul> <p>If active profile = prod \u2192 server.port = 8082 If no profile \u2192 server.port = 8080</p> <pre><code>@Profile(value={\"dev\"})\n@Component\npublic class User {\n    // Bean logic here\n}\n</code></pre> <p>What Happend?</p> <ul> <li><code>@Profile(\"dev\")</code> : loads the bean only when the active profile matches <code>\"dev\"</code>.</li> <li>Bean <code>User</code> is created and available in the Spring context.</li> <li>If active profile \u2260 \"dev\" : Bean User is not created and Spring skips it.</li> </ul>"},{"location":"spring-boot/8-logging/","title":"Logging in Spring Boot","text":"<ul> <li>Process of records events, errors, messages, and execution flow of an application.</li> <li>Spring Boot provides built-in logging support using SLF4J and Logback by default.</li> <li>All logs can be configured via application.properties/application.yml.</li> </ul>  Key Components Component Description SLF4J Simple Logging Facade for Java \u2014 abstraction layer for logging frameworks Logback Default logging implementation Logger for logging messages Log Levels Severity of logs (TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR) Enabling Log Levels <p>By default, only INFO and WARN logs are active .To enable others: In application.properties</p> <pre><code>logging.level.root=INFO\nlogging.level.com.example=DEBUG\n</code></pre> Logging Level Examples  <pre><code>#applies to all packages (java.*, org.*, com.*, etc.)\nlogging.level.root=DEBUG \n\n#applies to only org.framework package\nlogging.level.org.framework=DEBUG  \n\n#applies to only com.alamgir package\nlogging.level.com.alamgir=DEBUG\n</code></pre> Log display hirarchey Level Logs Displayed TRACE TRACE, DEBUG, INFO, WARN, ERROR DEBUG DEBUG, INFO, WARN, ERROR INFO INFO, WARN, ERROR WARN WARN, ERROR ERROR ERROR only OFF None Key Point  <ul> <li>TRACE : very detailed, fine-grained info</li> <li>DEBUG : debugging info, app flow</li> <li>INFO : general runtime info, milestones</li> <li>WARN : potential issues, recoverable problems</li> <li>ERROR : serious problems, app failures</li> </ul> <p>Example :</p> <pre><code>import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyService {\n    private static final Logger logger = LoggerFactory.getLogger(MyService.class);\n\n    public void doSomething() {\n        logger.trace(\"Trace log message\");\n        logger.debug(\"Debug log message\");\n        logger.info(\"Info log message\");\n        logger.warn(\"Warn log message\");\n        logger.error(\"Error log message\");\n    }\n}\n</code></pre> Log Output <p>Logs are printed in console by default.Can also write to files: <pre><code>logging.file.name=app.log\nlogging.file.path=/logs\n</code></pre></p> Logging Best Practices (Logback) <ul> <li>Don\u2019t log sensitive data (passwords, tokens).</li> <li>Avoid excessive logs : too many logs increase I/O load, disk usage, and reduce performance.</li> <li>Use appropriate log levels ( DEBUG for development, INFO for production)</li> </ul> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/data-jpa/1-entity-jpa-repository/","title":"Entity Class and JPA Repositroy","text":""},{"location":"spring-boot/data-jpa/1-entity-jpa-repository/#1-entity-class","title":"1. Entity ClassEntity class Example","text":"<ul> <li>A POJO that represents a table in the database.</li> <li>Fields are mapped to columns in the table.</li> <li>Class must have:<ul> <li>A no-arg constructor</li> <li>An <code>@Id</code> field (primary key)</li> </ul> </li> <li>@Entity <ul> <li>Table name defaults to class name (can customize with <code>@Table</code>).</li> <li>Part of JPA (javax.persistence.Entity).</li> <li>Required for Hibernate to manage the class.</li> </ul> </li> </ul> <p>@Id : Primary key of the entity.</p> <p>@Column : Maps field to DB column.</p> <p>@Table : Maps entity to DB table.</p> @GeneratedValue <p>used with @Id to specify how the primary key should be generated. Strategies  </p> <ul> <li> <p>AUTO : JPA chooses strategy based on DB dialect.</p> <ul> <li>MySQL : uses AUTO_INCREMENT (IDENTITY).</li> <li>PostgreSQL : uses SEQUENCE.</li> <li>Oracle : uses SEQUENCE</li> </ul> </li> <li> <p>IDENTITY : </p> <ul> <li>Uses DB auto-increment column.</li> <li>ID manage by DB.</li> </ul> </li> <li> <p>TABLE : uses an extra intermediate table for  ID generation.</p> <p>Here, </p> <ul> <li>sequence_name = 'User' identifies the sequence for the User entity.</li> <li>next_val is the next id Hibernate will assign.</li> </ul> </li> <li> <p>Entity with @TableGenerator Example Code <pre><code>   @Entity\n   public class User {\n\n     @Id\n     @GeneratedValue(strategy = GenerationType.TABLE, generator = \"user_table_gen\")\n     @TableGenerator(\n       name = \"user_table_gen\",           // generator name for Hibernate\n       table = \"hibernate_sequences\",     // table to store sequence values\n       pkColumnName = \"sequence_name\",    // column that stores sequence names\n       valueColumnName = \"next_val\",      // column that stores next value\n       pkColumnValue = \"User\",            // sequence name for this entity\n       initialValue = 1,                  // starting value\n       allocationSize = 1                 // increment per call\n     )\n     private int id;\n     private String name;\n     private String email;\n   }\n</code></pre> </p> </li> <li> <p>SEQUENCE </p> <ul> <li>Uses a database sequence to generate unique IDs.</li> <li>Supported by Oracle, PostgreSQL, DB2, etc.</li> </ul> </li> <li> <p>Entity with @SequenceGenerator</p> <p>Step 1: Create the sequence in DB</p> <pre><code>  -- PostgreSQL / Oracle\n  CREATE SEQUENCE user_seq\n  START WITH 1\n  INCREMENT BY 1\n</code></pre> <p>here ,</p> <ul> <li>user_seq : sequence name.</li> <li>START WITH 1 : first ID = 1</li> <li>INCREMENT BY 1 : each call increases by 1</li> </ul> <p>Step 2: Use @SequenceGenerator in Hibernate</p> </li> </ul> Code <pre><code>   @Entity\n   public class User {\n\n       @Id\n       @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"user_seq_gen\")\n       @SequenceGenerator(\n           name = \"user_seq_gen\",      // generator name in Hibernate\n           sequenceName = \"user_seq\", // database sequence name\n           allocationSize = 1        // increment per Hibernate call\n       )\n       private int id;\n       private String name;\n       private String email;\n   }\n</code></pre> without use of database sequence name <pre><code>@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"user_seq_gen\")\n    @SequenceGenerator(\n        name = \"user_seq_gen\", // generator name in Hibernate\n        initialValue = 10,    // starting value of the sequence\n        allocationSize = 1   // increment per Hibernate call\n    )\n    private int id;\n    private String name;\n    private String email;\n}\n</code></pre> Example Code <pre><code>  @Table(name=\"user-table\")\n  public class User{\n\n    @id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name=\"sid\")\n    private int id;\n\n    @Column\n    private String name;\n    //Getters and Setters \n  }\n</code></pre>"},{"location":"spring-boot/data-jpa/1-entity-jpa-repository/#2-jpa-repository","title":"2. JPA Repository","text":"<p>Pre-Defind interfaces provied by Spring JPA module.</p> <p>There are two types intefaces avaiable :</p> <ol> <li>CrudRepository (basic CRUD)  : Parent of JpaRepository</li> <li>JpaRepository (CRUD + extra features like pagination, sorting).</li> </ol> <p>Question: How to create JPA Repository?</p> <ul> <li>Create an interfaces by extending CrudRepository or JpaRepository .</li> </ul> CrudRepository and JpaRepository <p>provides database operations .</p> <ul> <li>Part of Spring Data JPA.</li> <li>Provides CRUD operations for entities.</li> <li>After extends, Spring auto-generates implementation (no SQL/DAO needed).</li> <li>Common Method: <code>save()</code>, <code>findAll()</code>, <code>findById()</code>, <code>deleteById()</code></li> </ul> <p>Example:</p> <p><pre><code>JpaRepository&lt;T, ID&gt;\n</code></pre> Here </p> <ul> <li>T : Entity class name</li> <li>ID :<ul> <li>Data type of identifier column of entity class.</li> <li>use wrapper class (<code>Integer</code> for int ,<code>Double</code> for double)</li> </ul> </li> </ul> <p>Example: JPA Repository <pre><code>public interface StudentRepository extends JpaRepository&lt;User, Integer&gt; {\n    //logic here \n}\npublic interface StudentRepository extends CrudRepository&lt;User, Integer&gt; {\n    //logic here \n}\n</code></pre> Here,</p> <ul> <li>StudentRepository manages the Student entity.</li> <li><code>JpaRepository&lt;User, Integer&gt;</code> and <code>CrudRepository&lt;User, Integer&gt;</code> here :<ul> <li>User : entity type.</li> <li>Integer : type of the primary key.</li> </ul> </li> </ul>"},{"location":"spring-boot/data-jpa/1-entity-jpa-repository/#3-uuiduniversally-unique-identifier","title":"3. UUID(Universally Unique Identifier)","text":"<ul> <li>128-bit value, usually represented as a 36-character string like: <code>550e8400-e29b-41d4-a716-446655440000</code></li> <li> <p>Very useful for distributed systems where auto-increment IDs can clash.</p> </li> <li> <p>Using in Java</p> </li> </ul> <pre><code>private UUID id = UUID.randomUUID();\n</code></pre> <ol> <li>Using in Hibernate</li> </ol> <pre><code>  @Entity\n  public class User {\n      @Id\n      @GeneratedValue(strategy = GenerationType.UUID)\n      private String id;\n      private String name;\n  }\n</code></pre> <ol> <li>Using in Column (MySql)</li> </ol> <pre><code>CREATE TABLE user (\n    id VARCHAR(255) PRIMARY KEY,\n    name VARCHAR(255)\n);\n</code></pre> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/data-jpa/2-crud-workflow/","title":"CRUD operation workflow","text":"<p>1. Create Database table. <pre><code>  CREATE TABLE user (\n      id INT,\n      name VARCHAR(50),\n      email VARCHAR(50)\n  );\n</code></pre> 2. Create Entity class <pre><code>@Entity(name = \"user\")\npublic class User {\n\n    @Id\n    @Column(name = \"uid\")\n    private int id;\n\n    @Column\n    private String name;\n\n    @Column\n    private String email;\n\n    //Getters and Setters\n}\n</code></pre> 3. Create JPA Repository <pre><code>public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {} \n</code></pre> 4. Perform Operation - Create a Bean class - Inject repository into bean class. - Repository having pre-defiend method to do DB operations.</p> <p><pre><code>@Component\npublic class Crud {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    public void insertUser() {\n        User u = new User();\n        u.setId(12);\n        u.setName(\"Alamgir\");\n        u.setEmail(\"alamgir.ahosain@gmail.com\");\n        userRepository.save(u);\n    }\n}\n</code></pre> 5. Call the method <pre><code>@SpringBootApplication\npublic class ECrudOpeationApplication {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(ECrudOpeationApplication.class, args);\n        Crud c = context.getBean(Crud.class);\n        c.insertUser();\n    }\n}\n</code></pre> </p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/data-jpa/3-crud-operation/","title":"CRUD Operation","text":""},{"location":"spring-boot/data-jpa/3-crud-operation/#q","title":"1. Question and Concepts","text":"1.1 @Transactional with Hibernate <ul> <li>opens a transaction before method execution and commits/rolls back after.</li> <li>Executes Hibernate operations (INSERT/UPDATE/DELETE).</li> <li>Without @Transactional : insert may not execute (no commit), or may hit <code>LazyInitializationException</code>.</li> </ul> 1.2 save() <p>save() does two things: insert or update</p> <ol> <li>If the object is new : it will insert it into the database.</li> <li>If the object already exists : it will update the existing record.</li> </ol> <p>How does it know if it\u2019s new or existing?</p> <p>It looks at the ID field (@Id):</p> <ol> <li>ID is null or not in DB \u2192 new \u2192 insert</li> <li>ID exists in DB \u2192 update</li> </ol> 1.3 Why Hibernate runs SELECT before INSERT? <ul> <li>Manual ID / merge() \u2192 check if entity exists or not.</li> <li>ID generation Strategy(AUTO, TABLE, SEQUENCE).</li> <li>Relationship checks (@ManyToOne, @OneToOne).</li> </ul> <pre><code>  sql: insert into user (id, name,email) values (1, 'a','a@gmail.com');\n\n  Hibernate: select u1_0.uid,u1_0.email,u1_0.name from user u1_0 where u1_0.uid=?\n  Hibernate: insert into user (email,name,uid) values (?,?,?)\n</code></pre> 1.4 Custom / Dervied findBy method Rules <ul> <li>Define abstract methods in the repository.</li> <li>Format: <code>findBy&lt;EntityClassPropertyName&gt;(DataType propertyArgumentName)</code>.</li> <li>Return type: allow zero or more records.</li> <li>Property name: first letter uppercase after <code>findBy</code>.</li> </ul> <p>Entity</p> <pre><code>@Entity\npublic class User{\n  private String name;\n\n  @Column(name=\"email\")\n  private String emailAddress;\n}\n</code></pre> <p>Repository</p> <pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n\n  List&lt;User&gt; findByName(String n);\n  List&lt;User&gt; findByEmailAddress(String e);\n  List&lt;User&gt; findByNameAndEmailAddress(String e,String n);\n  List&lt;User&gt; findByNameOrEmailAddress(String e,String n);\n}\n</code></pre>"},{"location":"spring-boot/data-jpa/3-crud-operation/#i","title":"2. Insert","text":"save() <ul> <li>SQL:</li> </ul> <pre><code>  INSERT INTO user VALUES (?, ?, ?);\n</code></pre> <ul> <li>Inserts a single record.</li> </ul> <p>Example:</p> <pre><code>User u = new User(1, \"a\", \"a@gmail.com\");\nuserRepository.save(u);\n</code></pre> saveAll() <ul> <li>SQL:</li> </ul> <pre><code>INSERT INTO user VALUES (?, ?, ?);\nINSERT INTO user VALUES (?, ?, ?);\n</code></pre> <ul> <li>Inserts multiple records at once.</li> </ul> <p>Example:</p> <pre><code>List&lt;User&gt; users = new ArrayList&lt;&gt;();\nusers.add(new User(2, \"b\", \"b@gmail.com\"));\nusers.add(new User(3, \"c\", \"c@gmail.com\"));\nuserRepository.saveAll(users);\n</code></pre>"},{"location":"spring-boot/data-jpa/3-crud-operation/#u","title":"3. Update","text":"<pre><code>    // load and save\npublic void updateUserById(int id, String email) {\n\n    Optional&lt;User&gt; optional = userRepository.findById(id);\n    if (optional.isPresent()) {\n      User user = optional.get();\n      user.setEmail(email);\n      userRepository.save(user);\n      } \n    else System.out.println(\"No record Found!\");\n}\n</code></pre>"},{"location":"spring-boot/data-jpa/3-crud-operation/#r","title":"4. Read / Select","text":"findAll() <ul> <li>SQL:</li> </ul> <pre><code>  SELECT * FROM user;\n</code></pre> <ul> <li>Returns all records from the table.</li> </ul> <p>Example:</p> <pre><code>List&lt;User&gt; users = userRepository.findAll();\nusers.forEach(u -&gt; {\n  System.out.println(u.getId()+\" \"+u.getName()+\" \"+u.getEmail());\n});\n</code></pre> findById() <ul> <li>SQL:</li> </ul> <pre><code>  SELECT * FROM user WHERE id = ?;\n</code></pre> <ul> <li>Always points to the identifier column of the entity.</li> <li>Returns single record wrapped in <code>Optional&lt;T&gt;</code> no record may be present.</li> </ul> <p>Example:</p> <pre><code>Optional&lt;User&gt; userOptional = userRepository.findById(1L);\nif (userOptional.isPresent()) {\n    User u = userOptional.get();\n    System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n} else {\n    System.out.println(\"User not found!\");\n}\n</code></pre>"},{"location":"spring-boot/data-jpa/3-crud-operation/#d","title":"5. Delete","text":"deleteById <ul> <li>The method does not return anything.</li> <li>should check record existence ( with <code>existsById</code>) before calling it to avoid exceptions.</li> </ul> <pre><code>public boolean deleteUserById(int id) {\n    if (userRepository.existsById(id)) {\n        userRepository.deleteById(id);\n        return true; // deleted\n    }\n    return false; // not found\n}\n</code></pre> <p>\u2191 Back to top </p> <p>Github Code : CRUD Operation </p>"},{"location":"spring-boot/data-jpa/4-ddl/","title":"DDL- Data Definition LanguageHibernate DDL Auto StrategiesQuestion: Should tables be created by JPA or by developers?","text":"<p>Used to define and manage the structure of database objects (tables, columns, indexes, constraints, etc).</p> <ul> <li>It changes the schema of the database, not the data itself.</li> <li>Main commands: <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>TRUNCATE</code>.</li> </ul> 1. spring.jpa.hibernate.ddl-auto=none <ul> <li>Hibernate does nothing with the schema.</li> <li><code>No validation, no creation, no update</code>.</li> <li>It just Assumes tables are already present in DB.</li> <li>Useful in production when schema is managed manually. </li> </ul> 2. spring.jpa.hibernate.ddl-auto=validate <ul> <li>Hibernate will check (validate) the schema against  entity mappings.</li> <li>If tables/columns don\u2019t exist or don\u2019t match : it throws an exception.</li> <li><code>Does not create or modify tables</code>.</li> <li>Good when want to make sure entity class and DB schema are in sync, but don\u2019t want Hibernate to change the DB.</li> </ul> 3. spring.jpa.hibernate.ddl-auto=update  <ul> <li>Hibernate checks if the table exists for entity class<ul> <li>If yes : it uses it.</li> <li>If no : it creates the table.(but only adds missing tables/columns, <code>doesn\u2019t remove old ones</code>).</li> </ul> </li> <li>Never drops or removes columns/tables.</li> <li>good when want Hibernate to auto-create missing tables/columns, but keep existing data safe.</li> </ul> 4. spring.jpa.hibernate.ddl-auto=create  <ul> <li>At startup : Hibernate drops existing tables.</li> <li>Then creates new tables for all entities.</li> <li>Every restart : <code>tables are dropped and re-created</code> (so old data is lost).</li> <li>Useful for testing/prototyping.</li> </ul> 5. spring.jpa.hibernate.ddl-auto=create-drop <ul> <li>Same as create: drops + recreates at startup.</li> <li>Additionally,<code>drops tables again when the application stops</code>.</li> <li>Schema only lives for the runtime of the app.</li> <li>Common for integration/unit tests. </li> </ul> <p>none = do nothing</p> <p>validate = Only checks tables/columns match entities and error if mismatch.</p> <p>update = Creates missing tables/columns, keeps existing data, never drops.</p> <p>create = Drops all tables, creates fresh ones at startup (data lost).</p> <p>create-drop = Same as create, but also drops tables again on app shutdown.</p> <ul> <li> <p>For learning / prototyping : let JPA auto-generate (fast, easy).</p> </li> <li> <p>For production : tables should be created/managed by developers (manual SQL or migration tools) beacuse it's safer, more control, better performance.</p> </li> </ul> <p>Best Practice : Always first create the DB tables (via SQL or migration tool), then map them with JPA entity classes.</p> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/data-jpa/5-sorting-pagination/","title":"Sorting and Pagination","text":""},{"location":"spring-boot/data-jpa/5-sorting-pagination/#s","title":"1. Sorting","text":"<pre><code>Iterable&lt;T&gt;\nfindAll(Sort sort)\n</code></pre> <p>Returns all entities sorted by the given options.</p> Sort by Name (Ascending) <pre><code>public void sortUser() {\n    List&lt;User&gt; users = userRepository.findAll(Sort.by(\"name\"));\n    users.forEach(u -&gt; {\n        System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n    });\n}\n</code></pre> Sort by Name (Descending) <pre><code>public void sortUserDesc() {\n    List&lt;User&gt; users = userRepository.findAll(Sort.by(Direction.DESC, \"name\"));\n    users.forEach(u -&gt; {\n        System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n    });\n}\n</code></pre>"},{"location":"spring-boot/data-jpa/5-sorting-pagination/#p","title":"Sort by Multiple Fields (ID + Name)Pageable.ofSize(n) : PageRequest.of(...)","text":"<pre><code>public void sortUserbyIdAndName() {\n    List&lt;User&gt; users = userRepository.findAll(Sort.by(Direction.DESC, \"id\", \"name\"));\n    users.forEach(u -&gt; {\n        System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n    });\n}\n</code></pre> 2. Pagination <p>Pagination allows to retrieve chunks of data (pages), rather than all rows at once. Page start index at 0</p> <p>Pageable.ofSize(n) : creates a Pageable that fetches the first page (page index = 0) with n records.  Fetch always first page with n records.</p> <pre><code> Page&lt;User&gt; pageObj = userRepository.findAll(Pageable.ofSize(3));\n</code></pre> <p>create a Pageable object, which internally tells Hibernate how to apply pagination (limit and offset) to the SQL queries.</p> <p>syntax: <pre><code>PageRequest.of(int page, int size)\nPageRequest.of(int page, int size, Sort sort)\n</code></pre> here ,</p> <ul> <li>page : zero-based page index (0 = first page).</li> <li>size : number of records per page.</li> <li>sort : optional for sorting.</li> </ul> Pagination with Sorting <pre><code>public void getUsersByPage(int pageNumber, int pageSize) {\n\n  // Page&lt;User&gt; pageObj = userRepository.findAll(PageRequest.of(pageNumber, pageSize));\n  // Page&lt;User&gt; pageObj = userRepository.findAll(PageRequest.of(pageNumber, pageSize, Sort.by(\"id\")));\n  // Page&lt;User&gt; pageObj = userRepository.findAll(PageRequest.of(pageNumber, pageSize, Sort.by(Direction.DESC, \"name\")));\n\n    Page&lt;User&gt; pageObj= userRepository.findAll(PageRequest.of(pageNumber, pageSize, Direction.DESC, \"id\"));\n    if (!pageObj.isEmpty()) {\n        List&lt;User&gt; users = pageObj.getContent();\n        sers.forEach(u -&gt; {\n        System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n\n      });\n   }\n}\n</code></pre> <p></p> <p>\u2191 Back to top </p> <p>Github Code : CRUD Operation </p>"},{"location":"spring-boot/data-jpa/6-native-sql/","title":"Native SQL Query","text":""},{"location":"spring-boot/data-jpa/6-native-sql/#1-native-query","title":"1. Native Query","text":"<ul> <li>Written in <code>plain SQL</code>.</li> <li>Works directly with database tables and columns.</li> <li>Database-specific (<code>not portable</code>).</li> </ul> Rules for creating native query <ul> <li>Create an abstract method inside Repository interface.</li> <li>Define return type of an entity class.</li> <li>on top of abstract method define <code>@Query</code> annotation.</li> </ul>"},{"location":"spring-boot/data-jpa/6-native-sql/#2-query","title":"2. @Query","text":"<p>configuring required SQL query to be executed.</p> 2 mandatory parameter <ul> <li>Value : query(String format)</li> <li>nativeQuery : boolean property(default is false)<ul> <li>true : JPA undertand given query is SQL language.</li> <li>false : it's JPQL not native SQL.</li> </ul> </li> </ul> <p>Example <pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n\n    @Query(value = \"SELECT * FROM USER\", nativeQuery = true)\n    List&lt;User&gt; getAllUser();\n}\n</code></pre> <pre><code>Hibernate: SELECT * FROM USER\n</code></pre> Hibernate directly sent to the query(as it is,no changes) in DB level.</p>"},{"location":"spring-boot/data-jpa/6-native-sql/#3-query-parameters","title":"3. Query Parameters","text":"<p>Two type of Query parameters :</p> <ol> <li>Indexed Query Parameter</li> <li>Named Query Parameter </li> </ol> 1. Indexed Query Parameter <ul> <li>Syntax: <code>?&lt;indexNumber&gt;</code></li> <li>Index <code>starts from 1</code></li> <li>Define method parameters as part of the abstract method.</li> </ul> <p>Repository Example</p> <p><pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n\n    @Query(value = \"SELECT * FROM user WHERE NAME=?1\", nativeQuery = true)\n    List&lt;User&gt; getUserByName(String name);\n}\n</code></pre> Method Example</p> <pre><code>public void getUserByNameMethod(String name) {\n    List&lt;User&gt; users = userRepository.getUserByName(name);\n    users.forEach(System.out::println);\n}\n</code></pre>  Multiple Index Parameters <p>Make sure the order of method parameters is the same as the column values.</p> <p>Repository Example</p> <p><pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n\n    @Query(value = \"SELECT * FROM user WHERE NAME=?1 AND EMAIL=?2\", nativeQuery = true)\n    List&lt;User&gt; getUserByNameAndEmail(String a, String b);\n}\n</code></pre> Here,</p> <ul> <li>?1 binds to the first method argument (a)</li> <li>?2 binds to the second method argument (b)</li> </ul> <p>Method Example</p> <pre><code>public void getAllUserParamsMethod(String name, String email) {\n    List&lt;User&gt; users = userRepository.getUserByNameAndEmail(name, email);\n    users.forEach(System.out::println);\n}\n</code></pre> 2. Named query parameter. <ul> <li>Avoid confusion of parameters order.</li> <li>Order doesn\u2019t matter when using named params.</li> <li>Increase Readbility.</li> <li><code>@Param</code> binds a repository method\u2019s argument to a named parameter (<code>:paramName</code>) in a JPQL or native SQL query.</li> </ul> <p>Syntax  <code>:parameterName</code></p> <p>Example <pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n\n    @Query(value = \"SELECT * FROM USER WHERE EMAIL=:myEmail AND NAME=:myName\", nativeQuery = true)\n    List&lt;User&gt; getUserByNameAndEmailNamed(@Param(\"myName\") String a, @Param(\"myEmail\") String b);\n}\n</code></pre></p> <p>key points</p> <ul> <li>First argument is annotated with <code>@Param(\"myName\")</code> \u2192 it will bind to <code>:myName</code></li> <li>Second argument is annotated with <code>@Param(\"myEmail\")</code> \u2192 it will bind to <code>:myEmail</code> </li> <li>Java variable names(<code>String a,String b</code>) doesn\u2019t matter.</li> <li>only the<code>@Param(\"...\")</code> values must match the query placeholders.</li> </ul> <pre><code>public void loadUserByNameAndEmailNamed(String name, String email) {\n\n        List&lt;User&gt; users = userRepository.getUserByNameAndEmailNamed(name, email);\n        users.forEach(System.out::println);\n    }\n</code></pre>"},{"location":"spring-boot/data-jpa/6-native-sql/#4-modifying","title":"4. @Modifying","text":"<p>@Modifying tells Spring Data JPA that a @Query changes data (INSERT, UPDATE, DELETE) instead of reading it.</p> <p>Key points:</p> <ul> <li>Used with @Query for update/delete operations.</li> <li>Often combined with @Transactional.</li> <li>Returns number of affected rows.</li> </ul> <p>Example <pre><code> @Modifying\n    @Query(value = \"DELETE FROM user WHERE NAME = ?1\", nativeQuery = true)\n    int deleteByName(String name);\n</code></pre> </p> <p>\u2191 Back to top </p> <p>Github Code : CRUD Operation </p>"},{"location":"spring-boot/data-jpa/7-jpql/","title":"JPQL (Java/Jakarta Persistence Query Language)","text":"<ul> <li>Avoiding SQL inside Java logic.</li> <li>Object-oriented query language for JPA.</li> <li>Works with entities and their fields, not database tables/columns.</li> <li>Portable across databases.</li> <li>Converted to SQL by JPA/Hibernate before executing in the database.</li> </ul> Rules for creating JPQL <ol> <li> <p>select all    <pre><code>SQL : SELECT * FROM USER\nJPQL: SELECT u FROM User u \n</code></pre></p> </li> <li> <p>select specific field      <pre><code>SQL : SELECT id,name FROM USER\nJPQL: SELECT u.id ,u.name FROM User\n</code></pre></p> </li> </ol> <p>Here(JPQL perspective)</p> <p>User = Entity class name (not table name). id, name = Entity property names (not column names).</p> <p></p> Example <p>Repository  <pre><code>public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n    @Query(value = \"SELECT u FROM User u \", nativeQuery = false)\n    List&lt;User&gt; getUserJpql();\n}\n</code></pre> Method  <pre><code> public void getUserJpqlMethod() {\n     List&lt;User&gt; users = userRepository.getUserJpql();\n      users.forEach(u -&gt; {\n      System.out.println(u.getId() + \" \" + u.getName() + \" \" + u.getEmail());\n     });\n }\n</code></pre> SQL  <pre><code>JPQL: SELECT u FROM User u \nSQL : SELECT * FROM USER\nHibernate: select u1_0.uid,u1_0.email,u1_0.name from user u1_0\n</code></pre></p> <p></p> <p>\u2191 Back to top </p> <p>Github Code : CRUD Operation </p>"},{"location":"spring-boot/data-jpa/8-entity-mapping/","title":"Entity Relationship Mapping","text":"Cascade Types <ul> <li> <p><code>CascadeType.PERSIST</code> : Saving the parent also saves the child.</p> </li> <li> <p><code>CascadeType.MERGE</code> : Updating the parent also updates the child.</p> </li> <li> <p><code>CascadeType.REMOVE</code> : Deleting the parent also deletes the child.</p> </li> <li> <p><code>CascadeType.REFRESH</code> : Refreshing the parent also refreshes the child from the DB.</p> </li> <li> <p><code>CascadeType.DETACH</code> : Detaching the parent also detaches the child from the persistence context.</p> </li> <li> <p><code>CascadeType.ALL</code> : Applies all of the above.</p> </li> </ul>"},{"location":"spring-boot/data-jpa/8-entity-mapping/#1-one-to-one-11","title":"1. One-to-One (1:1)","text":"<ol> <li>One entity is associated with exactly one other entity.</li> <li>Example: A User has one Profile.</li> </ol> <p>Entity example</p> Entity Example <pre><code>    @Entity\n    public class Profile{\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private int pid;\n        private String email; private String phone;\n        //Getters and Setters\n    }\n\n    @Entity\n    public class User{\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private int uid;\n        private String name; private String gender;\n\n        @OneToOne(cascade =CascadeType.ALL)\n        private Profile profile;\n        //Getters and Setters\n    }\n</code></pre> <p>here,</p> <ul> <li><code>cascade = CascadeType.ALL</code> : any operation on <code>User</code> will also apply to its <code>Profile</code></li> </ul> <p>SQL example</p> SQL Example <pre><code>    CREATE TABLE profile (\n        pid INT AUTO_INCREMENT PRIMARY KEY,\n        phone VARCHAR(20) NOT NULL,\n        email VARCHAR(255) NOT NULL,\n    );\n\n    CREATE TABLE user (\n        uid INT AUTO_INCREMENT PRIMARY KEY,\n        pid INT UNIQUE,\n        name VARCHAR(255) NOT NULL,\n        gender VARCHAR(255) NOT NULL,\n        FOREIGN KEY (pid) REFERENCES profile(pid) ON DELETE CASCADE\n    );\n</code></pre> <p>here ,</p> <ul> <li>A profile must exist before inserting a user(because of FK).</li> <li>ON DELETE CASCADE( to maintain data integrity)<ul> <li>Deleting a profile deletes the user automatically </li> <li>but deleting a user does not delete the profile.</li> <li>cascade only works one way here.</li> </ul> </li> </ul>"},{"location":"spring-boot/data-jpa/8-entity-mapping/#2-one-to-many-many-to-one-1n-n1","title":"2. One-to-Many / Many-to-One (1:N / N:1)","text":"<ul> <li>One entity is related to multiple other entities.</li> <li>Example: A user can place many orders, but each order belongs to one user.</li> </ul> Entity Example <pre><code>    @Entity\n    public class Orders{\n        @Id\n        private int oid;\n        private Strig name;\n    }\n\n    @Entity\n    public class User{\n        @Id\n        private int uid;\n        private String name;\n\n        @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n        @JoinColumn(name = \"user_uid\")\n        List&lt;Orders&gt; orders = new ArrayList&lt;&gt;();\n    }\n</code></pre> <p>here ,</p> <p>@JoinColumn(name = \"user_uid\"):</p> <ul> <li>Defines the foreign key column inside the Orders table.</li> <li>the Orders table will have a column <code>user_uid</code> pointing to <code>User(uid)</code>.</li> </ul> SQL Example  <pre><code>    CREATE TABLE orders (\n        oid INT PRIMARY KEY,\n        name VARCHAR(255),\n        user_uid INT,\n        FOREIGN KEY (user_uid) REFERENCES user(uid)\n    );\n\n    CREATE TABLE user (\n        uid INT PRIMARY KEY,\n        name VARCHAR(255),\n    );\n</code></pre>"},{"location":"spring-boot/data-jpa/8-entity-mapping/#3-many-to-many-mn","title":"3. Many-to-Many (M:N)","text":"<ul> <li>Multiple entities can be associated with multiple others.</li> <li>Example : User has many Roles, and one Role has many Users</li> </ul> <p>The join table is required in a many-to-many relationship because relational databases cannot directly represent M:N relationships between two tables.</p> Entity Example  <pre><code>    @Entity\n    public class Roles{\n\n        @Id\n        private int rid;\n        private String name;\n    }\n\n    @Entity\n    public class User{\n\n        @Id\n        private int uid;\n        private String name;\n\n        @ManyToMany(cascade = CascadeType.MERGE, fetch = FetchType.EAGER)\n        @JoinTable(name = \"user_roles_join\", joinColumns = @JoinColumn(name = \"uid\"),\n                        inverseJoinColumns = @JoinColumn(name = \"rid\"))\n        List&lt;Roles&gt; roles = new ArrayList&lt;&gt;();\n    }\n</code></pre> <p>here ,</p> <p>@JoinTable:</p> <ul> <li>Defines the third table that connects User and Roles.</li> <li>Table name: <code>user_roles_join</code></li> <li><code>joinColumns (uid)</code> : Refers to the User entity\u2019s primary key.</li> <li><code>inverseJoinColumns (rid)</code> : Refers to the Roles entity\u2019s primary key.</li> </ul> SQL Example  <pre><code>    CREATE TABLE user (\n        uid INT PRIMARY KEY,\n        name VARCHAR(255) NOT NULL\n    );\n\n    CREATE TABLE roles (\n        rid INT PRIMARY KEY,\n        name VARCHAR(255) NOT NULL\n    );\n\n    CREATE TABLE user_roles_join (\n        uid INT NOT NULL,\n        rid INT NOT NULL,\n        PRIMARY KEY (uid, rid),\n        FOREIGN KEY (uid) REFERENCES user(uid),\n        FOREIGN KEY (rid) REFERENCES roles(rid)\n    );\n</code></pre> <p></p> <p>\u2191 Back to top </p> <p>Github Code : Entity Relationship Mapping </p>"},{"location":"spring-boot/spring-security/1-JWT-token-generate%20copy/","title":"JWT Authentication : Generate JWT","text":"<ul> <li>JWT is an open source standard used to securely share information between client-server applications.</li> <li>Using JWT, we can  Generate tokens and Validate tokens.</li> </ul>"},{"location":"spring-boot/spring-security/1-JWT-token-generate%20copy/#1-jwt-structure","title":"* 1. JWT Structure","text":"<ul> <li>Header: Contains algorithm and token type</li> </ul> <p><pre><code>{\n\"alg\": \"HS256\",  The algorithm used to sign the JWT\n\"typ\": \"JWT\"     The media type of this complete JWT \n}\n</code></pre> * Payload: Contains claims </p> <p><pre><code>{\n \"sub\": \"1234567890\", The subject of the JWT (the user)\n \"name\": \"alamgir\",\n \"iat\": 1516239022 The time at which the JWT was issued.\n}\n</code></pre> * JWT Signature Verification: Ensures integrity and authenticity</p>"},{"location":"spring-boot/spring-security/1-JWT-token-generate%20copy/#2-cryptography-concepts","title":"2. Cryptography Concepts","text":"SHA-256 (Secure Hash Algorithm 256-bit) <ul> <li>Cryptographic hash function</li> <li>Fixed output: 256 bits (32 bytes / 64 hex chars)</li> <li>One-way (irreversible)</li> <li>Same input \u2192 same hash</li> <li>Small input change \u2192 big output change</li> <li>Hard to find collisions (two inputs with same hash)</li> <li>Used in passwords, signatures, integrity checks, blockchain</li> </ul> HMAC (Hash-based Message Authentication Code) <ul> <li>Uses a secret key + hash function (e.g., SHA-256)</li> <li>Output length depends on the hash function (e.g., 256 bits for SHA-256)</li> <li>Provides integrity (data not altered)</li> <li>Provides authenticity (from trusted sender)</li> <li>Resistant to tampering and length-extension attacks</li> <li>Used in APIs, JWTs, secure tokens, SSL/TLS</li> </ul> HS256 Signing Algorithm <ul> <li>HMAC with SHA-256</li> <li>Symmetric key algorithm:</li> <li>One secret key shared between sender and receiver</li> <li>Same key used for generating and validating the signature</li> </ul>"},{"location":"spring-boot/spring-security/1-JWT-token-generate%20copy/#3-jwt-creation-steps","title":"3. JWT Creation Steps","text":"<ol> <li>Header \u2192 Base64 (<code>b64Header</code>)</li> <li>Payload \u2192 Base64 (<code>b64Payload</code>)</li> <li>Combine: <code>headerPayload = b64Header + \".\" + b64Payload</code></li> <li>Signature: <code>HMAC-SHA256(secretKey, headerPayload)</code></li> <li>Encode signature \u2192 Base64(hash)</li> <li> <p>JWT: <code>jwt = b64Header + \".\" + b64Payload + \".\" + hash</code></p> </li> <li> <p>We can verify output at jwt.io</p> </li> </ol> Token Validation <ul> <li>Check expiration time: compare <code>expired</code> claim with current time</li> <li>Extract username from token: compare with request username</li> </ul> Create  token,Validate JWT token <pre><code>package com.alamgir.l_spring_boot_security_jwt.security;\n\nimport java.util.Date;\nimport javax.crypto.SecretKey;\nimport org.springframework.stereotype.Component;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\n\n@Component\npublic class JwtUtil {\n\n    private final String SECRET_KEY = \"F3r7lG7OZt+2k4Q0l9U+7Vq2g6LkpB1D8uVhb3cW+rY=\"; // Base64 256-bit key\n    private final long TOKEN_EXPIRY_DURATION = 5 * 60 * 1000; // 5 mins\n\n    public SecretKey getSecretKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n\n    // Create JWT Token\n    public String createToken(String username) {\n        return Jwts.builder()\n                .subject(username)\n                .issuedAt(new Date(System.currentTimeMillis()))\n                .expiration(new Date(System.currentTimeMillis() + TOKEN_EXPIRY_DURATION))\n                .signWith(getSecretKey()) // \"alg\": \"HS256\", \"typ\": \"JWT\" auto-set     //! JJWT automatically sets `\"alg\": \"HS256\"` when using an HMAC key.It also adds `\"typ\": \"JWT\"` to mark the token as a JSON Web Token.\n                .compact();\n    }\n\n    // Decode and Extract username\n    public String extractUsername(String token) {\n        return Jwts.parser()\n                .verifyWith(getSecretKey())\n                .build()\n                .parseSignedClaims(token)\n                .getPayload()\n                .getSubject();\n    }\n\n    // Check if token is expired\n    public boolean isTokenExpired(String token) {\n        Date expiryTime = Jwts.parser()\n                .verifyWith(getSecretKey())\n                .build()\n                .parseSignedClaims(token)\n                .getPayload()\n                .getExpiration();\n        return expiryTime.before(new Date());\n    }\n\n    // Validate token\n    public boolean isValidToken(String token, String requestedUsername) {\n        String usernameFromToken = extractUsername(token);\n        return usernameFromToken.equalsIgnoreCase(requestedUsername)\n                &amp;&amp; !isTokenExpired(token);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-security/1-JWT-token-generate%20copy/#4override-and-integration-spring-security-with-jwt","title":"4.Override and  Integration Spring Security  with JWT","text":"1. Add Spring Boot Security Starter <pre><code>&lt;dependency&gt;  \n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;  \n    &lt;version&gt;3.5.6&lt;/version&gt;  \n&lt;/dependency&gt;\n</code></pre> <ul> <li>By default, APIs show 401 Unauthorized</li> <li>Default credentials in console: <code>username / password</code></li> </ul> 2. Add JJWT Library <pre><code>&lt;dependency&gt;  \n    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;  \n    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;  \n    &lt;version&gt;0.13.0&lt;/version&gt;  \n&lt;/dependency&gt;\n</code></pre> <p>\u2191 Back to top </p>"},{"location":"spring-boot/spring-security/2-authentication-class/","title":"Important Classes &amp; Their Roles in JWT Authentication","text":""},{"location":"spring-boot/spring-security/2-authentication-class/#1-userdetails","title":"1. UserDetails","text":"<ul> <li>An Interface representing a Spring Security user.</li> <li>Maps  user entity to Spring Security.</li> <li>Purpose: Provide authentication-related info to Spring Security.</li> <li> <p>Key methods to implement:</p> <ul> <li><code>getUsername()</code> \u2192 return unique username/email</li> <li><code>getAuthorities()</code> \u2192 return roles/permissions</li> <li><code>isAccountNonExpired()</code> \u2192 account validity</li> <li><code>isAccountNonLocked()</code> \u2192 account lock status</li> <li><code>isCredentialsNonExpired()</code> \u2192 credentials validity</li> <li><code>isEnabled()</code> \u2192 account enabled/disabled</li> </ul> </li> </ul> Example <pre><code>@Entity\npublic class User implements UserDetails {\n\n  @Id\n  private String email;\n  private String password;\n\n  @Override\n  public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; }\n\n  @Override\n  public String getUsername() { return email;}\n}\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#2-userdetailsservice","title":"2. UserDetailsService","text":"<ul> <li>An Interface used by Spring Security to load user information during authentication.</li> <li>Returns a UserDetails object.</li> <li>Usually implemented in a service class.</li> <li> <p>Key methods to implement:</p> <ul> <li><code>UserDetails loadUserByUsername(String username) throws UsernameNotFoundException</code></li> </ul> </li> </ul> <p>UserDetailsService bridges  database user entity and Spring Security for authentication.</p> Example <pre><code>@Component\npublic class UserAuthenticationServiceImpl implements UserDetailsService {\n\n   @Autowired\n  UserRepository userRepository;\n\n  @Override\n  public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {\n\n      // load data from DB for a specific user\n       Optional&lt;User&gt; user = userRepository.findByEmail(email);\n       If (user.isPresent()) { return user.get();  }\n       else throw new UsernameNotFoundException(\"Email not Found :\" + email);\n    }\n}\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#3-authenticationmanager","title":"3. AuthenticationManager","text":"<ul> <li>Role: Core interface responsible for authenticating user credentials.</li> <li> <p>Key Functionality:</p> <ul> <li>Returns Authentication on success, throws <code>BadCredentialsException</code> on failure.</li> <li>Uses configured authentication providers (like <code>DaoAuthenticationProvider</code>) to validate credentials.</li> </ul> </li> <li> <p>Usage: Called in the login controller or authentication service.</p> </li> </ul> <p>Example </p> <pre><code>Authentication authentication = authenticationManager.authenticate(\n    new UsernamePasswordAuthenticationToken(username, password)\n);\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#4-bcryptpasswordencoder","title":"4. BCryptPasswordEncoder","text":"<ul> <li>Role: Encrypts passwords using the BCrypt hashing algorithm.</li> <li> <p>Key Functionality:</p> <ul> <li>Provides <code>encode()</code> to hash passwords.</li> <li>Provides <code>matches()</code> to verify raw password against hashed one.</li> </ul> </li> </ul> <p>example</p> <pre><code>passwordEncoder.encode(password);\npasswordEncoder.matches(rawPassword, encodedPassword);\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#5-securityfilterchain","title":"5. SecurityFilterChain","text":"<ul> <li>Role: Defines the security configuration and registers custom filters.</li> <li> <p>Key Functionality:</p> <ul> <li>Replaces deprecated <code>WebSecurityConfigurerAdapter</code>.</li> <li>Defines which endpoints require authentication and which are public.</li> <li>Registers custom filters (like <code>JwtAuthenticationFilter</code>).</li> </ul> </li> <li> <p>Usage Example:</p> </li> </ul> example <pre><code>@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http.csrf().disable()\n        .authorizeHttpRequests()\n        .requestMatchers(\"/auth/**\").permitAll()\n        .anyRequest().authenticated()\n        .and()\n        .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n    return http.build();\n}\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#6-onceperrequestfilter","title":"6. OncePerRequestFilter","text":"<ul> <li>Role: Base class for custom filters executed once per HTTP request.</li> <li> <p>Key Functionality:</p> <ul> <li>Intercepts each HTTP request.</li> <li>Used to create custom filters like <code>JwtAuthenticationFilter</code>.</li> <li>Extracts and validates JWT from the header.</li> <li>Sets authentication in the SecurityContextHolder if valid.</li> </ul> </li> <li> <p>Usage: Added to the Spring Security filter chain before - <code>UsernamePasswordAuthenticationFilter</code>.</p> </li> </ul> <p>example</p> <pre><code>String token = request.getHeader(\"Authorization\");\nif (token != null &amp;&amp; jwtService.validateToken(token)) {\n    // set authentication context\n}\nfilterChain.doFilter(request, response);\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#7-securitycontextholder","title":"7. SecurityContextHolder","text":"<ul> <li>Role: Holds the security context (authentication details) for the current thread.</li> <li> <p>Key Functionality:</p> <ul> <li>Associates a given SecurityContext with the current execution thread.</li> <li>Stores <code>Authentication</code> object once user is successfully authenticated.</li> <li>Provides global access to authentication info anywhere in the app.</li> </ul> </li> <li> <p>Important Methods:</p> <ul> <li><code>getContext()</code> \u2192 Gets the current security context.</li> <li><code>setContext(SecurityContext context)</code> \u2192 Sets a new context.</li> <li><code>clearContext()</code> \u2192 Clears authentication info.</li> </ul> </li> </ul> <p>Example</p> <pre><code>Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#8-usernamepasswordauthenticationtoken","title":"8. UsernamePasswordAuthenticationToken","text":"<ul> <li>Role: Represents the authentication object used to hold username and password credentials.</li> <li> <p>Key Functionality:</p> <ul> <li>Used to pass login credentials to <code>AuthenticationManager</code>.</li> <li>Carries login data (username, password).</li> <li>After authentication, stores authorities (roles).</li> </ul> </li> <li> <p>Important Methods:</p> <ul> <li><code>getPrincipal()</code> \u2192 Returns username.</li> <li><code>getCredentials()</code> \u2192 Returns password.</li> <li><code>setAuthenticated(boolean isAuthenticated)</code> \u2192 Marks the authentication status.</li> </ul> </li> </ul> <p>example</p> <pre><code>Authentication auth = new UsernamePasswordAuthenticationToken(username, password);\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#9-filterchain","title":"9. FilterChain","text":"<ul> <li>Role: Manages the flow of multiple filters during an HTTP request.</li> <li> <p>Key Functionality:</p> <ul> <li>Passes the request/response to the next filter.</li> <li>Allows or blocks access based on authentication.</li> <li>Important Methods:</li> </ul> </li> <li> <p><code>doFilter(ServletRequest request, ServletResponse response)</code> \u2192 Passes the request to the next filter.</p> </li> </ul> <p>Example</p> <pre><code>  filterChain.doFilter(request, response);\n</code></pre>"},{"location":"spring-boot/spring-security/2-authentication-class/#10-flow-in-jwt-authentication","title":"10.  Flow in JWT Authentication","text":"<ul> <li>User sends credentials \u2192 verified by AuthenticationManager.</li> <li>UserDetailsService loads user data from DB.</li> <li>BCryptPasswordEncoder validates password.</li> <li>JWT token generated and returned to user.</li> <li> <p>On each request:</p> <ul> <li><code>OncePerRequestFilter</code> validates token.</li> <li><code>SecurityContextHolder</code> stores authentication.</li> <li><code>SecurityFilterChain</code> manages which requests are secured.</li> </ul> </li> </ul> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/spring-security/3-request-workflow/","title":"9.3 JWT Request workflow","text":"JWT Authentication Workflow in Spring Boot Security <p>This document explains the step-by-step workflow of JWT (JSON Web Token) authentication in a Spring Boot application using Spring Security.</p>"},{"location":"spring-boot/spring-security/3-request-workflow/#1defining-user-credentials-entity-class","title":"1.Defining User Credentials (Entity Class)","text":"<ul> <li>Create an entity class that implements <code>UserDetails</code>.  </li> <li>This allows Spring Security to treat your custom <code>User</code> entity as a core security object.</li> </ul> code <pre><code>@Entity\n@Table(name = \"user_info\")\npublic class User implements UserDetails {\n\n    @Id\n    @Column(unique = true, nullable = false)\n    private String email;\n\n    private String name;\n\n    @Column(nullable = false)\n    private String password;\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {return null; // No roles for now}\n\n    @Override\n    public String getUsername() {   return email;  }\n\n    //getters ans setters\n}\n}\n</code></pre> <p>Key Points:</p> <ul> <li>The <code>email</code> acts as the username for authentication.</li> <li>Spring Security uses this <code>UserDetails</code> interface to encapsulate user information.</li> </ul>"},{"location":"spring-boot/spring-security/3-request-workflow/#2-loading-user-information-userdetailsservice","title":"2. Loading User Information (UserDetailsService)","text":"<p>Spring Security uses an implementation of <code>UserDetailsService</code> to fetch user details from the database for authentication.</p> Code <pre><code>@Service\npublic class UserAuthenticationServiceImpl implements UserDetailsService {\n\n    Logger logger = LoggerFactory.getLogger(UserAuthenticationServiceImpl.class);\n\n    @Autowired\n    UserRepository repository;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        logger.info(\"UserAuthenticationServiceImpl : loading data from DB of username  : \"+username);\n        User user = repository.findByEmail(username);\n        if (user == null) { \n            ogger.info(\"UserAuthenticationServiceImpl : username is not found in DB\");\n            throw new UsernameNotFoundException(\"Invalid User Name : \"+username);\n            }\n\n            return user;\n    }\n}\n</code></pre> <p>Workflow:</p> <ol> <li>When a user tries to log in, the <code>loadUserByUsername()</code> method is automatically called.</li> <li>The method retrieves the user by email from the database.</li> <li>If found, it returns a valid <code>UserDetails</code> object.</li> </ol>"},{"location":"spring-boot/spring-security/3-request-workflow/#3-security-configuration","title":"3. Security Configuration","text":"<p>The security configuration defines which endpoints are public and which are protected, and it integrates the JWT filter before the default authentication filter.</p> Code <pre><code>@Configuration\npublic class AppSecurityConfig {\n\n    Logger logger = LoggerFactory.getLogger(AppSecurityConfig.class);\n\n    @Autowired\n    JWTTokenFilter jwtTokenFilter;\n\n    @Bean\n    AuthenticationManager getAuthenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\n        logger.info(\"AppSecurityConfig : Initilizing Bean AuthenticationManager\");\n        return authenticationConfiguration.getAuthenticationManager();\n        }\n\n    @Bean\n    BCryptPasswordEncoder getBCryptPasswordEncoder() {\n     logger.info(\"AppSecurityConfig : Initilizing Bean BCryptPasswordEncoder\");\n      return new BCryptPasswordEncoder();\n      }\n\n    @Bean\n    public SecurityFilterChain getSecurityFilterChain(HttpSecurity security) throws Exception {\n        logger.info(\"AppSecurityConfig : Configuring SecurityFilterChain Layer  of URl patterns\");\n        security.csrf(csrf -&gt; csrf.disable())\n                .cors(cors -&gt; cors.disable())\n                .authorizeHttpRequests(\n                    auth -&gt; auth.requestMatchers(\"/public/**\")\n                                .permitAll()\n                                .anyRequest()\n                                .authenticated())\n                .addFilterBefore(this.jwtTokenFilter, UsernamePasswordAuthenticationFilter.class);\n        return security.build();\n    }\n}\n</code></pre> <p>Workflow:</p> <ul> <li><code>/public/**</code> endpoints are accessible without authentication.</li> <li>All other routes require a valid JWT token.</li> <li><code>JWTTokenFilter</code> is added before <code>UsernamePasswordAuthenticationFilter</code> in the chain.</li> </ul>"},{"location":"spring-boot/spring-security/3-request-workflow/#4-jwt-token-validation-filter-layer","title":"4. JWT Token Validation (Filter Layer)","text":"<p>Spring\u2019s <code>OncePerRequestFilter</code> ensures each HTTP request passes through the JWT validation logic once per request.</p> Code <pre><code>@Component\npublic class JWTTokenFilter extends OncePerRequestFilter {\n\n    Logger logger = LoggerFactory.getLogger(JWTTokenFilter.class);\n\n    @Autowired\n    JwtTokenHelper jwtTokenHelper;\n\n    @Autowired\n    UserAuthenticationServiceImpl authenticationService;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)   throws ServletException, IOException {\n\n        logger.info(\"JWTTokenFilter : validation of JWT token by OncePerRequestFilter\");\n       // Step 1: Extract the Authorization header (JWT Token)\n        String token = request.getHeader(\"Authorization\");\n\n        logger.info(\"JWT token : \" + token);\n        String userName = null;\n        // Step 2: Extract username from the token (if token exists)\n        if (token != null) {\n            userName = this.jwtTokenHelper.extractUsername(token);\n            logger.info(\"JWTTokenFilter : Request Token come from an User : \" + userName);\n        } else {\n            logger.info(\"ToKen is Misisng. Please Come with Token\");\n        }\n\n        // Step 3: Validate token and authenticate user\n        if (userName != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n\n            logger.info(\"JWTTokenFilter : getting user info from DB\");\n             // Step 4: Load user details from database\n            UserDetails userDetails = this.authenticationService.loadUserByUsername(userName);\n            logger.info(\"JWTTokenFilter :  Now Validating  the token \");\n\n            // Step 5: Validate the token\n            Boolean isValidToken = this.jwtTokenHelper.isValidToken(token, userDetails.getUsername());\n            logger.info(\"JWTTokenFilter : Is it Valid Token : \" + isValidToken);\n\n            // Step 6: If valid, set authentication in SecurityContext\n            if (isValidToken) {\n\n                logger.info(\"JWTTokenFilter : Setting Security Context for that username\");\n                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n            }\n\n        }\n        // Step 7: Continue the filter chain\n        filterChain.doFilter(request, response);\n    }\n\n}\n</code></pre> <p>Workflow</p> 1. Extract Token <ul> <li>Retrieve the <code>Authorization</code> header from the HTTP request.</li> </ul> 2. Extract Username: <ul> <li>Get the username encoded inside the JWT.</li> </ul> 3. Check if User Needs Authentication <p><pre><code>    If username !=null  &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null\n</code></pre>  Proceed to authentication\u00a0only if:</p> <ul> <li><code>userName</code>\u00a0is extracted successfully from the token,\u00a0AND</li> <li>The current request does\u00a0not already have\u00a0an authenticated user in\u00a0<code>SecurityContextHolder</code>.</li> </ul> 4. Load User Details from Database <ul> <li>The filter calls\u00a0<code>UserDetailsService.loadUserByUsername()</code>\u00a0to fetch user details from the database.</li> <li>This confirms the user exists in the system; if not, token validation is skipped.</li> </ul> 5.  Validate the Token <ul> <li>if token is valid<ul> <li>Set Authentication in SecurityContext: Build a <code>UsernamePasswordAuthenticationToken</code> and set it in the <code>SecurityContextHolder</code>.</li> <li>This marks the user as authenticated for the current request.</li> </ul> </li> </ul> 6. When Token Is Missing or Invalid <ul> <li>Public API Request: Skips token validation and proceeds.</li> <li>Protected API Request:<ul> <li>If token is\u00a0missing\u00a0or\u00a0invalid,\u00a0<code>SecurityContextHolder</code>\u00a0remains empty.</li> <li>Spring Security denies access and returns\u00a0<code>401 Unauthorized</code>.</li> </ul> </li> </ul>   7: Continue the Filter Chain <ul> <li>After token validation (or if no token exists), pass the request to the next filter in the chain.</li> <li>If the user is authenticated, they can access protected resources.</li> <li>If not, they'll receive a\u00a0<code>401 Unauthorized</code>\u00a0response (handled by Spring Security)</li> </ul>"},{"location":"spring-boot/spring-security/3-request-workflow/#5-user-login-flow-token-generation","title":"5. User Login Flow (Token Generation)","text":"<p>When a user logs in with valid credentials, the system authenticates and issues a JWT.</p> Code <pre><code>@PostMapping(\"/public/login\")\npublic ResponseEntity&lt;UserLoginResponse&gt; loginUser(@Valid @RequestBody UserLoginRequest loginRequest) {\n\n   this.doAuthenticate(loginRequest.getEmail(), loginRequest.getPassword());\n   String token = this.jwtTokenHelper.createToken(loginRequest.getEmail());\n   eturn ResponseEntity.ok(new UserLoginResponse(loginRequest.getEmail(), token));\n }\n\n\npublic void doAuthenticate(String username, String password) {\n\n   logger.info(\"Authentication of User credentials\");\n   UsernamePasswordAuthenticationToken credentials = new UsernamePasswordAuthenticationToken(username, password);\n\n    try { authenticationManager.authenticate(credentials);  } \n    catch (BadCredentialsException e) {throw new RuntimeException(\"Invalid username and password\");   }\n }\n</code></pre> Flow: <ol> <li>User sends a POST request with <code>{ \"email\": \"...\", \"password\": \"...\" }</code>.</li> <li>Credentials are verified using the authentication manager.</li> <li>If valid, JWT is generated via <code>JwtTokenHelper.createToken()</code>.</li> <li>The token is returned to the client for future authenticated requests.</li> </ol>"},{"location":"spring-boot/spring-security/3-request-workflow/#6-scenario","title":"6. Scenario","text":"Scenario Behavior Token is valid User authenticated \u2192 <code>SecurityContextHolder</code> populated \u2192 Access granted Token is invalid or expired Authentication fails \u2192 <code>SecurityContextHolder</code> remains empty \u2192 401 Unauthorized Token is missing Public API: Access grantedProtected API: 401 Unauthorized Token present but user not in DB <code>UsernameNotFoundException</code> thrown \u2192 401 Unauthorized"},{"location":"spring-boot/spring-security/3-request-workflow/#7-summary-flow-diagram","title":"7. Summary Flow Diagram","text":"<p>\u2191 Back to top </p> <p>Github Code : JWT - Token Based Authentication</p>"},{"location":"spring-boot/web-mvc/1-port-and-contextpath/","title":"Configure Port numberContext path","text":"<p>A port is a virtual endpoint that lets applications and services communicate over a network.</p> <ul> <li>Default Port: Run on port 8080 by default(accessible at http://localhost:8080/).</li> <li>can configure a custom port in application.properties <code>server.port=8012</code></li> <li>After this, project  will be accessible at http://localhost:8012/</li> </ul> <p>Defines the root path of an application.</p> <ul> <li> <p>In Servlets </p> <ul> <li>The context path is usually the name of the WAR file deployed.</li> <li>If deploy myproject.war ,this project accessible at http://localhost:8080/myproject</li> <li>Can be changed by modifying the <code>server.xml</code> or the deployment descriptor.</li> </ul> </li> <li> <p>In Spring Boot</p> <ul> <li>By default, Spring Boot run at the root (/) : http://localhost:8080/</li> <li>To set a custom context path, configure it in <code>application.properties or application.yml</code>: <code>server.servlet.context-path=/myproject</code></li> <li>After this, project  will be accessible at http://localhost:8080/myproject</li> </ul> </li> </ul> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/10-Swagger%20API%20Documentation/","title":"4.10 Swagger API Documentation","text":"Swagger API Documentation <ul> <li>Automates REST API documentation in Spring Boot.</li> <li>Collects all endpoints and displays them in a UI format.</li> <li> <p>To enable add dependency: <code>Swagger starter</code> (e.g., springdoc-openapi-starter-webmvc-ui).</p> <pre><code>&lt;!-- https://mvnrepository.com/artifact/com.spring4all/swagger-spring-boot-starter --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.spring4all&lt;/groupId&gt;\n    &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> <p>Access Swagger UI: <pre><code>http://hostname:port/context-path/swagger-ui.html\n</code></pre></p> </li> </ul>"},{"location":"spring-boot/web-mvc/11-Controller%20vs%20RestController/","title":"@Controller vs @RestController","text":"1. @Controller <ul> <li>@Controller tells Spring that this class contains web request handler methods.</li> <li>Marks a class as a Spring MVC controller.</li> <li>Handles web requests (GET/POST).</li> <li>Returns a view name(resolved by ViewResolver) instead of raw data.</li> <li>Used for web pages (MVC), not REST APIs.</li> <li>specialized forms of <code>@Component</code>.</li> </ul> <pre><code>@Controller\npublic class HomeController {\n\n    @RequestMapping(path = \"/home\", method = RequestMethod.GET)\n    public String homePage() {\n        // This will be resolved to home.jsp or home.html\n        return \"home\";\n    }\n}\n</code></pre> 2. @ResponseBody <ul> <li>Tells Spring not to render a view, but instead Sends return value directly to HTTP response.</li> <li>Used for JSON, XML, or text.</li> <li>Can be applied to methods in a @Controller.</li> </ul> <pre><code>@Controller\npublic class UserController {\n\n    @RequestMapping(path = \"/user\", method = RequestMethod.GET)\n    @ResponseBody\n    public String userMessage() {\n        // This will return JSON (if Jackson is on the classpath)\n        return \"message\";\n    }\n}\n</code></pre> 3. @RestController <p>A convenience annotation that combines: @Controller + @ResponseBody</p> <ul> <li>Every method automatically returns data (JSON/XML) instead of view.</li> <li>Commonly used for REST APIs.</li> </ul> <pre><code> @RestController\npublic class ProductController {\n\n     RequestMapping(path = \"/product\", method = RequestMethod.GET)\n    public String productMessage() {\n        return \"message\";\n        // No need to use @ResponseBody, handled automatically\n    }\n}\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"spring-boot/web-mvc/12-requestmapping/","title":"@RequestMapping","text":"<ul> <li>Handles web requests for one or more HTTP methods(GET, POST, PUT, DELETE).</li> <li>Can be applied at both class and method levels.</li> </ul> <p>Syntax <pre><code>@RequestMapping(\n    value = \"/path\",               // or path = \"/path\"\n    method = RequestMethod.GET,    // HTTP method(s)\n    params = \"id=10\",              // restrict by query parameters\n    headers = \"key=value\",         // restrict by request headers\n    consumes = \"application/json\", // accepted Content-Type\n    produces = \"application/json\"  // response Content-Type\n)\n</code></pre></p>"},{"location":"spring-boot/web-mvc/12-requestmapping/#1-path-only-mapping-url-only","title":"1. Path-Only Mapping (URL-only)","text":"<p>if don\u2019t specify the method attribute, it handles all HTTP method .</p> <pre><code>@RequestMapping(path = \"/user\")\n</code></pre> <p>Handles : <pre><code>GET      localhost:8080/user\nPOST     localhost:8080/user \nPUT      localhost:8080/user \nDELETE   localhost:8080/user \n</code></pre></p>"},{"location":"spring-boot/web-mvc/12-requestmapping/#2-method-specific-mapping-path-http-method","title":"2. Method-Specific Mapping (Path + HTTP Method)","text":"Case 2.1: Same Path &amp; Same Method <pre><code>@RequestMapping(path = \"/user\", method = RequestMethod.GET)\n@RequestMapping(path = \"/user\", method = RequestMethod.GET)\n</code></pre> <p>What happens?</p> <p>Spring throws an \"Ambiguous mapping\" error at startup because it cannot decide which method to use.</p> <pre><code>java.lang.IllegalStateException: Ambiguous mapping. Cannot map 'controllerName' method \n</code></pre> Case 2.2: Same Path, Different Methods <p><pre><code>@RequestMapping(path = \"/user\", method = RequestMethod.GET)\n@RequestMapping(path = \"/user\", method = RequestMethod.POST)\n</code></pre> What happens?</p> <p>This is valid and commonly used.Spring will map:</p> <pre><code>GET     localhost:8080/user\nPOST    localhost:8080/user \n</code></pre> Case 2.3: Multiple Methods in One Mapping <p><pre><code>@RequestMapping(path = \"/user\", method = {RequestMethod.GET,RequestMethod.PUT})\n</code></pre> Handles both GET and PUT for /user.</p>"},{"location":"spring-boot/web-mvc/12-requestmapping/#3-base-url-mapping","title":"3. Base URL Mapping","text":"<p>every method inside starts with /user.</p> <p><pre><code>@RestController\n@RequestMapping(\"/user\")\npublic class UserController{\n\n    @GetMapping(\"/profile\")  public String getProfile() { }\n    @GetMapping(\"/order\") public String getOrder() { }\n}\n</code></pre> Results: <pre><code>GET   localhost:8080/user/profile   \nGET   localhost:8080/user/order  \n</code></pre></p>"},{"location":"spring-boot/web-mvc/12-requestmapping/#4-shorthand-method-specific-mappings","title":"4. Shorthand (Method-Specific) Mappings","text":"<pre><code>@GetMapping(\"/path\")                         //Handles GET requests only\n@PostMapping(\"/path\")                        //Handles POST requests only\n@PutMapping(\"/path\")                         //Handles PUT requests only\n@DeleteMapping(\"/path\")                     //Handles DELETE requests only\n@DeleteMapping(path={\"/path\",\"/pathtwo\"})   //Handles DELETE requests only\n</code></pre>"},{"location":"spring-boot/web-mvc/12-requestmapping/#5-consumes-and-produces","title":"5. Consumes and Produces","text":"5.1. consumes <ul> <li>Defines what Content-Type the API can accept (request body format).</li> <li>Matches <code>client\u2019s Content-Type header</code>.</li> <li>Example: consumes = \"application/json\" \u2192 accepts only JSON input.</li> <li>Mismatch \u2192 <code>415 Unsupported Media Type</code>.</li> </ul> 5.2. produces <ul> <li>Defines what data format the API returns.</li> <li>Matches <code>client\u2019s Accept header</code>.</li> <li>Example: produces = \"application/xml\" \u2192 returns XML response.</li> <li>Mismatch \u2192 <code>406 Not Acceptable</code>.</li> </ul> <pre><code>    @RequestMapping(\n    path = \"/user\", \n    method = RequestMethod.GET,\n    consumes = MediaType.APPLICATION_JSON_VALUE\n    )\n\n    @RequestMapping(\n    path = \"/user\", \n    method = RequestMethod.POST,\n    produces = MediaType.APPLICATION_JSON_VALUE\n    )\n</code></pre> <p>produces : defines response type (Accept header). consumes : defines request type (Content-Type header).</p>"},{"location":"spring-boot/web-mvc/12-requestmapping/#6-requestbody","title":"6. @RequestBody","text":"<p>Used to read the HTTP request body into a Java object (POJO).</p> <ul> <li>Matches with the consumes attribute.</li> <li>Incoming request body from a client.</li> <li>work as method parameter level specific to POJO class aligned to request body.</li> </ul> <pre><code>@PostMapping(\"/user\")\npublic String createUser(@RequestBody User user) { ... } \n// Here ,User class is a POJO class (not entity or any type) \n</code></pre>"},{"location":"spring-boot/web-mvc/12-requestmapping/#7-responcebody","title":"7. @ResponceBody","text":"<ul> <li>Outgoing responce body to a client.</li> <li>work as method level.</li> <li>Matches with the <code>produces attribute</code>.</li> <li>return type/ value converted to respective data format(JSON/XML) as per configuration produces attribute.</li> </ul>"},{"location":"spring-boot/web-mvc/12-requestmapping/#8-content-negotiation-conversion-producesconsumes","title":"8. Content Negotiation &amp; Conversion (produces/consumes)","text":"Case 8.1 \u2013 Based on produces: <p><pre><code>produces = \"application/json\" \u2192 JSON converter \u2192 JSON response\nproduces = \"application/xml\"  \u2192 XML converter  \u2192 XML response\n</code></pre> Each produces type determines which message converter is used for the response.</p> Case 8.2 \u2013 Multiple Formats <pre><code>produces = {\"application/xml\", \"application/json\"}\n</code></pre> Client <code>Accept</code> Header Converter Used Response Format <code>application/xml</code> XML converter XML response <code>application/json</code> JSON converter JSON response <code>*/*</code> (any) JSON converter (default) JSON response <p>Spring checks the client\u2019s Accept header and chooses the correct converter. Defaults to JSON if not specified.</p> Case 8.3 \u2013 Single Format <pre><code>produces = \"application/json\"\n</code></pre> Client <code>Accept</code> Header Supported? Response <code>application/xml</code> No 406 Not Acceptable <code>application/json</code> Yes JSON response <code>*/*</code> Yes JSON response <p>Only JSON responses are allowed.</p> Case 8.4 \u2013 Based on consumes: <pre><code>consumes = \"application/xml\"\n</code></pre> Client <code>Content-Type</code> Supported? Action XML Yes Request accepted \u2192 XML converter JSON No 415 Unsupported Media Type <p>The consumes type specifies which input format the API accepts.</p> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/13-Json%20Property/","title":"@JsonProperty","text":"<ul> <li>Part of Jackson library for JSON serialization/deserialization.</li> <li>Maps a Java field/getter/setter to a specific JSON property name.</li> <li>Useful when <code>JSON field names differ from Java field names</code>.</li> </ul> <p>Example <pre><code>public class User {\n    @JsonProperty(\"user_name\")\n    private String userName;\n\n    @JsonProperty(\"user_email\")\n    private String email;\n}\n</code></pre></p> <p>Resulting JSON:</p> <p><pre><code>{\n  \"user_name\": \"Alamgir\",\n  \"user_email\": \"alamgir@example.com\"\n}\n</code></pre> </p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/14-requestBody%20validation/","title":"@RequestBody Validation","text":"<ul> <li>Used with @Valid or @Validated to validate incoming request body (POJO) before method execution.</li> <li>If validation fails, throws a <code>MethodArgumentNotValidException</code> and returns a 400 Bad Request response.</li> </ul> <p>Requirements:</p> <ul> <li>Add <code>spring-boot-starter-validation</code> dependency (Hibernate Validator).</li> <li>Add validation annotations in the model ( @NotNull,@NotEmpty,@Email).</li> <li>Use @Valid or @Validated before the @RequestBody parameter.</li> </ul> <p>Example</p> <pre><code>@PostMapping(\"/user\")\npublic void createUser(@Valid @RequestBody User user) {}\n</code></pre> <p>Model Class :  <pre><code>public class User {\n    @NotBlank\n    private String name;\n\n    @Email\n    private String email;\n\n    @Min(18)\n    private int age;\n}\n</code></pre></p> <p>In Invalid request:  <pre><code>{\n  \"name\": \"\",\n  \"email\": \"invalid\",\n  \"age\": 15\n}\n</code></pre></p> <p>Response: 400 Bad Request With error details like: <pre><code>{\n  \"errors\": [\n    \"name must not be blank\",\n    \"email must be a valid email address\",\n    \"age must be greater than or equal to 18\"\n  ]\n}\n</code></pre></p> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/15-Path%20vs%20Query%20Parameters/","title":"4.15 Path Parameters vs Query Parameters","text":"Path Parameters vs Query Parameters"},{"location":"spring-boot/web-mvc/15-Path%20vs%20Query%20Parameters/#1-path-variabless-path-parameters","title":"1. Path variabless / path parameters","text":"<ul> <li>Used to pass resource identifiers in the URI path.</li> <li>Always part of the URI and enclosed in curly braces {}.</li> <li>Binding values to method parameters using <code>@PathVariable</code>.</li> <li>Suitable for public data or mandatory identifiers.</li> <li>name attribute optional if parameter name matches the path variable.</li> </ul> <p>Example <pre><code>@RequestMapping(path = \"/user/{email}\", method = RequestMethod.GET)\npublic void readByEmail(@PathVariable(name=\"email\") String emailId){}\n\n@RequestMapping(path = \"/user/info/{id}\", method = RequestMethod.GET)\npublic void readById(@PathVariable int id){}\n</code></pre> Access :</p> <pre><code>GET  localhost:8080/user/abc@gmail.com\nGET  localhost:8080/user/info/12\n</code></pre> Multiple Path Variables <pre><code> @RequestMapping(path = \"/user/{id}/{email}\", method = RequestMethod.GET)\n public void read(@PathVariable int id ,@PathVariable String email){}\n</code></pre> <p>Access :</p> <pre><code>GET  localhost:8080/user/info/12/abc@gmail.com\n</code></pre>"},{"location":"spring-boot/web-mvc/15-Path%20vs%20Query%20Parameters/#2-query-parameters-request-parameters","title":"2. Query Parameters /request parameters","text":"<ul> <li>Passed via the URI after <code>?</code> in <code>key=value</code> form.</li> <li>Multiple query params are separated by <code>&amp;</code>.</li> <li>Use<code>@RequestParam</code> to bind values to method parameters.</li> <li>By default, parameters are mandatory (can be optional with <code>required=false</code>).</li> </ul> <p>Example <pre><code>@RequestMapping(path = \"/user/info\", method = RequestMethod.GET)\npublic void read(@RequestParam String country) {}\n</code></pre></p> <p>Access :</p> <pre><code>GET  localhost:8080/user/info?country=Bangladesh\n</code></pre> Multiple Parameters <pre><code>@RequestMapping(path = \"/user/info\", method = RequestMethod.GET)\npublic void read(@RequestParam String country, @RequestParam String city) {}\n</code></pre> <p>Access : <pre><code>GET  localhost:8080/user/info?country=Bangladesh&amp;city=Tangail\n</code></pre></p> Optional Parameters  <pre><code>@RequestMapping(path = \"/user/info\", method = RequestMethod.GET)\npublic void read(@RequestParam(name=\"country\" ,required=false) String countryName, \n                 @RequestParam(required=false) String city){\n\n     if(countryName!=null &amp;&amp; city!=null){getByCountryAndCity()}\n     else if(countryName!=null &amp;&amp; city==null){getByCountry()}\n     else if(countryName==null &amp;&amp; city!=null){getByCity()}\n     else if(countryName==null &amp;&amp; city==null){getAllUser()}\n}\n</code></pre> <p>Access :</p> <pre><code>/user/info                     \u2192 Get all users\n/user/info?country=Bangladesh  \u2192 Get users filtered by country\n/user/info?city=Tangail        \u2192 Get users filtered by city\n/user/info?country=Bangladesh&amp;city=Tangail \u2192 Get users filtered by both country and city\n</code></pre>"},{"location":"spring-boot/web-mvc/15-Path%20vs%20Query%20Parameters/#3-combination-of-path-and-query-parameters","title":"3. Combination of Path and Query Parameters","text":"<pre><code> @RequestMapping(path = \"/user/{id}\", method = RequestMethod.GET)\npublic void getUser(\n    @PathVariable int id,\n    @RequestParam(required=false) String country,\n    @RequestParam(required=false) String city\n) {}\n</code></pre> <p>Access : <pre><code>/user/12                     \u2192 Get user with id 12\n/user/12?country=Bangladesh  \u2192 Get user 12 filtered by country\n/user/12?city=Tangail        \u2192 Get user 12 filtered by city\n/user/12?country=Bangladesh&amp;city=Tangail \u2192 Both filters applied\n</code></pre></p>"},{"location":"spring-boot/web-mvc/15-Path%20vs%20Query%20Parameters/#4-path-vs-query-parameters","title":"4. Path vs Query Parameters","text":"<ul> <li>if having limited no of properties and all are mandatory then go with path parameters.</li> <li>when mandatory and optional properties then go with query parametes. </li> </ul> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/16-HTTP%20responce%20status%20code/","title":"HTTP Response Status Codes","text":"<ul> <li>3-digit numbers returned by a server.</li> <li>Represent the execution status or outcome of an HTTP request.</li> <li>Always provided by the web server or web application after processing a request.</li> </ul> Category Code Range Meaning 1xx 100\u2013199 Informational 2xx 200\u2013299 Success 3xx 300\u2013399 Redirection 4xx 400\u2013499 Client Error 5xx 500\u2013599 Server Error Common Codes Code Meaning Description 100 Continue Request received, continue. 101 Switching Protocols Protocol change accepted. 102 Processing Request in progress. 200 OK Request succeeded. 201 Created New resource created. 202 Accepted Request accepted for processing, but not completed yet. 204 No Content Success, no body returned. 301 Moved Permanently Resource moved to new URL. 302 Found Temporary redirect. 304 Not Modified Cached version still valid. 400 Bad Request Invalid syntax. 401 Unauthorized Authentication needed. 403 Forbidden Access denied. 404 Not Found Resource doesn\u2019t exist. 405 Method Not Allowed HTTP method not supported for the resource. 500 Internal Server Error General server error. 503 Service Unavailable Server overloaded or down."},{"location":"spring-boot/web-mvc/16-HTTP%20responce%20status%20code/#difference-between-204-and-404","title":"Difference Between 204 and 404ResponseEntity in Spring","text":"Status Code Meaning When Used Response Body 204 No Content Request succeeded, but there\u2019s no content to return. When the server successfully processes a request, but doesn\u2019t need to send any data back (e.g., DELETE success, or empty result set). No body 404 Not Found The requested resource doesn\u2019t exist on the server. When the client asks for a resource (URL) that\u2019s not found or invalid. No body (or optional error message) <p>Example - 204 \u2192 \"User deleted successfully, no data to return.\" - 404 \u2192 \"User not found in the system.\"</p> <ul> <li>Represents the whole HTTP response.</li> <li>Used to control status code, headers, and body in a REST API response.</li> <li>Belongs to package: <code>org.springframework.http</code>.</li> <li>Structure : <code>ResponseEntity&lt;T&gt;</code></li> </ul> <pre><code>@RequestMapping(path = \"/user/v2\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE)\n    public ResponseEntity&lt;String&gt; createUser2(@RequestBody UserRequest userRequest) {\n\n        String msg = userService.CreateUser(userRequest);\n\n        if (msg.equals(\"User Created Succesfully..\")) {\n            // return new ResponseEntity&lt;String&gt;(msg, HttpStatusCode.valueOf(201));\n            return ResponseEntity.status(HttpStatus.CREATED).body(msg);\n        }\n        // return new ResponseEntity&lt;String&gt;(msg, HttpStatusCode.valueOf(200));\n        // return ResponseEntity.ok(msg);\n        return ResponseEntity.status(HttpStatus.OK).body(msg);\n    }\n</code></pre> <pre><code> return ResponseEntity.ok(msg);\n return new ResponseEntity&lt;String&gt;(msg, HttpStatusCode.valueOf(200));\n\n return ResponseEntity.noContent().build();\n return new ResponseEntity&lt;String&gt;(null, HttpStatusCode.valueOf(204));\n</code></pre> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/17-HTTP%20headers/","title":"HTTP Headers Types of HeadersCommon Request Headers Common Response Headers2. Add Header to Response","text":"<ul> <li>Used to share metadata between client and server.  </li> <li>Sent as part of HTTP request and response.  </li> <li>Represented as key\u2013value pairs.  </li> <li>Can include custom headers (e.g., <code>X-Auth-Token</code>).  </li> </ul> Type Description General Headers Apply to both requests and responses. Request Headers Sent by client to provide information about the request. Response Headers Sent by server to provide information about the response. Entity Headers Describe the body content (if present). Header Description Example <code>Host</code> Domain name of the server. <code>Host: example.com</code> <code>User-Agent</code> Info about client software. <code>User-Agent: Chrome/141.0</code> <code>Accept</code> Expected response format. <code>Accept: application/json</code> <code>Authorization</code> Credentials for authentication. <code>Authorization: Bearer &lt;token&gt;</code> <code>Cookie</code> Sends stored cookies. <code>Cookie: sessionId=abc123</code> Header Description Example <code>Content-Type</code> Media type of the response body. <code>Content-Type: application/json</code> <code>Content-Length</code> Size of response body in bytes. <code>Content-Length: 348</code> <code>Server</code> Server software info. <code>Server: Apache/2.4.56</code> <code>Set-Cookie</code> Sends cookies to client. <code>Set-Cookie: sessionId=abc123</code> <code>Location</code> Used in redirects. <code>Location: /login</code> <code>Cache-Control</code> Defines caching rules. <code>Cache-Control: no-cache</code> Request Headers  <p>Example</p> <pre><code>GET /users HTTP/1.1\nHost: api.example.com\nAccept: application/json\nAuthorization: Bearer xyz123\n</code></pre> Response Headers <p>Example</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-cache\n</code></pre>  1. Read Header Value from Request <p>To read header values from an incoming request, two common ways:</p> <ul> <li>Using RequestHeader<ul> <li>Reads a specific header directly.</li> <li>Use<code>@RequestHeader Map&lt;String, String&gt;</code> to get all headers.</li> </ul> </li> <li>Using HttpServletRequest<ul> <li><code>request.getHeader(\"name\")</code> : read a single header.</li> <li><code>request.getHeaderNames()</code> : get all header names.</li> </ul> </li> </ul> @RequestHeader \u2013 Required and Default Value Behavior <pre><code>@RequestHeader(\n    name=\"Security-token\" ,\n    required=false,\n    defaultValue = \"token\"\n    ) String token\n</code></pre> Client Sends Header? <code>required</code> Value <code>defaultValue</code> Provided? Result Description Yes \u2014 \u2014 Value from client The header value sent by client is used. No <code>required = true</code> \u2014 400 Bad Request Header is mandatory, but missing. No <code>required = false</code> \u2014 Value = <code>null</code> Header is optional; value will be <code>null</code>. No <code>required = false</code> Yes Value = token Default value used instead of <code>null</code>. <p>Using ResponseEntity</p> <p><pre><code>@GetMapping(\"/custom-header\")\npublic ResponseEntity&lt;String&gt; sendHeader() {\n    return ResponseEntity\n            .ok()\n            .header(\"X-App-Name\", \"SpringBootDemo\")\n            .body(\"Header added successfully!\");\n}\n</code></pre> Here,</p> <ul> <li>header(\"name\", \"value\") \u2192 Adds custom header to response.</li> <li>add multiple headers: .headers(HttpHeaders headers)</li> </ul> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/18-consuming-rest-api/","title":"Spring REST Client","text":"<ul> <li>REST clients in Spring ( RestTemplate, RestClient, WebClient, and OpenFeign) </li> <li>used to consume or call external REST services.  </li> <li>Aacting as HTTP clients for communicating with other APIs(send requests and receive responses).</li> </ul> Requirements for Consuming a REST API <p>When consuming an external REST service, you need to know:</p> <ul> <li>API URL \u2013 The endpoint of the target REST API.</li> <li>HTTP Method \u2013 e.g., GET, POST, PUT, or DELETE.</li> <li>Response Type \u2013 The Java type (class) expected in the response.</li> <li>Request Body \u2013 The data to send (if applicable).</li> <li>Required Headers \u2013 Such as Content-Type, Authorization, etc.</li> </ul> Handling JSON Responses <p>When the API returns a JSON payload, create a POJO class that matches the response structure. Pass this POJO class as the response type in RestTemplate.</p> <p>Example:</p> <pre><code>[\n    {\n    \"id\": 1,\n    \"title\": \"Fjallraven - Foldsack No. 1 Backpack, Fits 15 Laptops\",\n    \"price\": 109.95,\n    \"description\": \"Your perfect pack for everyday use and walks in the forest.\"\n    },\n    .....\n]\n</code></pre> <pre><code>public class ProductDto {\n    private int id;\n    private String title;\n    private double price;\n    private String description;\n}\n</code></pre> <pre><code>ResponseEntity&lt;ProductDto&gt; response =\n    restTemplate.getForEntity(url, ProductDto.class);\n</code></pre> HttpEntity <p>HttpEntity is used to wrap both the request body and headers together.</p> <pre><code>HttpHeaders headers = new HttpHeaders();\nheaders.set(\"Authorization\", \"Bearer token\");\nheaders.setContentType(MediaType.APPLICATION_JSON);\n\nHttpEntity&lt;ProductDtoRequest&gt; entity = new HttpEntity&lt;&gt;(requestBody, headers);\nResponseEntity&lt;ProductDto&gt; response =  restTemplate.exchange(url, HttpMethod.POST, entity, ProductDto.class);\n</code></pre>"},{"location":"spring-boot/web-mvc/18-consuming-rest-api/#comparison-of-rest-api-clients-in-spring-boot","title":"Comparison of REST API Clients in Spring Boot","text":"Client Type Synchronous Asynchronous Recommended For Notes RestTemplate Yes No Simple apps Deprecated but maintained WebClient No Yes Reactive systems Best for scalable, non-blocking use cases RestClient Yes Optional Modern Spring Boot (3.2+) Easiest and preferred API style today OpenFeign Yes No Microservices architecture Declarative client with annotation support <p>\u2191 Back to top </p> <p>Github Code : Consuming REST API</p>"},{"location":"spring-boot/web-mvc/19-exception-handling/","title":"Exception Handling in REST Services","text":"<p>Validation Note</p> <p>The validation annotations @NotEmpty and @NotBlank cannot be applied to int or Integer type fields.They are only valid for CharSequence, Collection, Map, or Array types, not numeric types.</p>"},{"location":"spring-boot/web-mvc/19-exception-handling/#eo","title":"1. Exception Handling Overview","text":"<p>In Spring Boot REST APIs, exception handling can be centralized using <code>@ControllerAdvice</code> and <code>@ExceptionHandler</code>.These annotations separate exception-handling logic from the business logic in controllers.</p>"},{"location":"spring-boot/web-mvc/19-exception-handling/#c","title":"2. Controller Advice Class","text":"<ul> <li>A class annotated with <code>@ControllerAdvice</code></li> <li>Contains methods annotated with <code>@ExceptionHandler</code></li> <li>Acts as a centralized/global exception handler for all controllers</li> <li>Used to handle exceptions globally as part of a request lifecycle</li> <li>Can handle specific exception types via separate <code>@ExceptionHandler</code> methods</li> </ul>"},{"location":"spring-boot/web-mvc/19-exception-handling/#em","title":"3. Exception Handler Methods","text":"<p>An exception handler method is defined inside either a controller or a controller advice class.</p> <p>Rules</p> <ul> <li>The return type should be <code>ResponseEntity&lt;?&gt;</code></li> <li>Inside <code>@ExceptionHandler,</code> specify which exception(s) to handle.</li> <li>The method can accept:<ul> <li>The exception type as a parameter.</li> <li>Optionally, an <code>HttpServletRequest</code> argument for request-specific details.</li> </ul> </li> </ul> <p>Example  <pre><code>@ExceptionHandler(ResourceNotFoundException.class)\npublic ResponseEntity&lt;String&gt; handleResourceNotFound(\n    ResourceNotFoundException ex, HttpServletRequest request) {\n    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Resource not found: \" + ex.getMessage());\n}\n</code></pre></p>"},{"location":"spring-boot/web-mvc/19-exception-handling/#d","title":"4. Default (Catch-All) Exception Handler","text":"<p>If no specific exception type is defined, a generic handler can be used to catch all unhandled exceptions \u2014 acting as a fallback <pre><code>@ExceptionHandler(Exception.class)\npublic ResponseEntity&lt;String&gt; handleException(Exception ex) {\n    return ResponseEntity.internalServerError().body(\"An unexpected error occurred. Please try again later.\");\n}\n</code></pre></p>"},{"location":"spring-boot/web-mvc/19-exception-handling/#s","title":"5. Scope of Exception Handling","text":"<p>If  define an <code>@ExceptionHandler</code> method </p> Level Location Scope Description Controller-level Inside controller Local only handles exceptions thrown by that controller. Global-level Inside <code>@ControllerAdvice</code> Application-wide handles exceptions thrown by any controller in the application."},{"location":"spring-boot/web-mvc/19-exception-handling/#ef","title":"6. Exception Handling Flow","text":"<ul> <li>If an exception occurs inside a controller:<ul> <li>Spring first checks if that controller has a local <code>@ExceptionHandler</code> method for that exception.</li> </ul> </li> <li>If not found:<ul> <li>Spring then looks for a matching handler in any <code>@ControllerAdvice</code> class.</li> </ul> </li> <li>If still not found:<ul> <li>A default Spring error response is returned.</li> </ul> </li> </ul> <p>\u2191 Back to top </p> <p>Github Code : Exception Handling </p>"},{"location":"spring-boot/web-mvc/2-stereotype-annotations/","title":"Stereotype Annotations","text":"<ul> <li>Special annotations that tell Spring which layer a class belongs to.</li> <li>When Spring starts, it scans packages (<code>via @ComponentScan</code>) and registers the class as a Spring Bean in the <code>ApplicationContext</code>.</li> <li>Can be injected with @Autowired / constructor injection.</li> </ul> <p>Main Stereotype Annotations</p> <ol> <li>@Component</li> <li>@Controller</li> <li>@Service</li> <li>@Repository</li> </ol> 1. @Component <ul> <li>Marks class as a Spring-managed bean.</li> <li>Must create Default Constructor otherwise throws <code>UnsatisfiedDependencyException</code> .</li> <li>Bean object created with deafult constructor execution.</li> <li>Can't configure value in bean object(always use default values for properties).</li> <li>Used as Class level.</li> </ul> 2. @Controller <ul> <li>@Controller tells Spring that this class contains web request handler methods.</li> <li>Marks a class as a Spring MVC controller.</li> <li>Handles web requests (GET/POST).</li> <li>Returns a view name(resolved by ViewResolver) instead of raw data.</li> <li>Used for web pages (MVC), not REST APIs.</li> <li>specialized forms of @Component.</li> </ul> 3. @Service <p>@Service = business logic bean, managed by Spring, used to separate concerns in MVC.</p> <ul> <li>Contains business logic.</li> <li>Supports AOP features (@Transactional).</li> <li>specialized forms of @Component.</li> </ul> 4. @Repository <p>@Repository marks a class as a data access component (DAO) in the persistence layer.</p> <ul> <li>Indicates that the class interacts with the database (CRUD operations, queries).</li> <li>Can be used with Spring Data JPA for repository interfaces, though optional there.</li> <li>specialized forms of @Component.</li> </ul> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/3-mvc-architecture/","title":"MVC Architecture","text":"<ul> <li>The Model-View-Controller (MVC) framework is a design pattern that separates an application into three components: Model,View ,Controller.</li> <li>Each part has a clear responsibility, making applications easier to develop, maintain, and scale.</li> </ul>"},{"location":"spring-boot/web-mvc/3-mvc-architecture/#com","title":"MVC Three Components","text":"<ul> <li>View<ul> <li>Represents the UI (User Interface).</li> <li>Should not contain business logic.</li> </ul> </li> <li> <p>Controller</p> <ul> <li>Acts as a bridge between Model and View.</li> <li>A java class which can handle a HTTP request coming from view layer.</li> <li>Handles user requests, processes them, calls the Model for data, and returns output to the View.</li> </ul> </li> <li> <p>Model</p> <ul> <li>write logic which is responsible for Database communication.</li> <li>Manages database, state, rules, and validations.</li> <li>Represents the data and business logic.</li> <li>Model layer divided into two part : <ul> <li>Service<ul> <li>Contains business logic.</li> <li>Coordinates between Controller and Repository.</li> </ul> </li> <li>Repository<ul> <li>Handles database operations.</li> <li>Uses Spring Data JPA / Hibernate for CRUD.</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"spring-boot/web-mvc/3-mvc-architecture/#flow","title":"Flow of MVCDisadvantages","text":"<ul> <li>User sends a request.</li> <li>Controller receives the request and calls the Model.</li> <li>Model interacts with the database / business logic and returns data.</li> <li>Controller passes the data to the View.</li> <li>View renders the response back to the user.</li> </ul> <ul> <li>Can be complex for small applications.</li> <li>Requires understanding of layer interactions.</li> <li>Sometimes causes extra layers of code.</li> </ul> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/4-mvc-workflow/","title":"MVC workflow","text":"1. View layer <ul> <li>The View is responsible for presenting forms/pages to the user.</li> <li>Example: Registration Form (HTML/JSP/Thymeleaf)</li> </ul> Example Code <pre><code>    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;form action=account/login method=POST&gt;\n            &lt;input type=\"text\" placeholder=\"Enter Name\" name=\"name\" id=\"name\" required&gt; &lt;/\n            &lt;input type=\"text\" placeholder=\"Enter Email\" name=\"email\" id=\"email\" required&gt; &lt;/\n            &lt;input type=\"password\" placeholder=\"Enter Password\" name=\"password\" id=\"password\" required&gt;\n            &lt;input type=\"submit\" value=\"Register\"/&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre> 2. Controller layer <ul> <li>Receives data from form submission, calls the Service Layer, and returns a view name with data.</li> </ul> Example Code <pre><code>    @Controller\n    public class UserController {\n\n        @Autowired\n        private UserService userService;\n\n        // Show Registration Page\n        @RequestMapping(path = \"/registration\", method = RequestMethod.GET)\n        public String showRegistrationForm() {\n            return \"registration_form\";\n        }\n\n        // Handle Form Submission\n        @RequestMapping(path = \"/account/login\", method = RequestMethod.POST)\n        public ModelAndView handleUserRegistration(HttpServletRequest request) {\n            String name = request.getParameter(\"name\");\n            String email = request.getParameter(\"email\");\n            String password = request.getParameter(\"password\");\n\n            // Call Service Layer\n            String msg = userService.RegisterUser(name, email, password);\n\n            // Send response back to view\n            ModelAndView mav = new ModelAndView();\n            mav.setViewName(\"login\");\n            mav.addObject(\"message\", msg);\n            return mav;\n        }\n    }\n</code></pre> 3. Service Layer <ul> <li>Contains business logic.</li> <li>Controller pass tasks to the service.</li> <li>Service interacts with the Repository layer.</li> </ul> Example Code <pre><code>@Service\n    public class UserService {\n\n        @Autowired\n        private UserRepository userRepository;\n\n        public String RegisterUser(String name, String email, String password) {\n            System.out.println(\"Name: \" + name + \"Email :\" + email + \"Password: \" + password);\n\n            if (userRepository.existsByEmail(email)) {\n                return \"Duplicate Email\";\n            }\n\n            User u = new User();\n            u.setName(name);\n            u.setEmail(email);\n            u.setPassword(password);\n            userRepository.save(u);\n            return \"Created Succesfully\";\n        }\n    }\n</code></pre> 4. Repository Layer <ul> <li>Responsible for database operations.</li> <li>Uses Spring Data JPA to interact with the DB.</li> </ul> Example Code <pre><code>    @Repository\n    public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {\n        boolean existsByEmail(String email);\n    }\n</code></pre> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/5-how-mvc-works/","title":"How Spring MVC Works Internally?","text":"Front Controller Design Pattern <p>Spring MVC follows the Front Controller design pattern.</p> <ul> <li>A Front Controller is a single controller that handles all incoming requests and sends back responses.</li> <li>In Spring MVC, the DispatcherServlet acts as the Front Controller.</li> </ul> Step 1: Request to DispatcherServlet <ul> <li>First, when a user sends a request, it always comes to the <code>DispatcherServlet</code>.</li> <li>Example: <code>GET http://localhost:8080/home</code></li> </ul> Step 2: Handler Mappings <p>At application startup, Spring scans all @Controller classes and builds a Handler Mapping of all @RequestMapping methods. Example:</p> <p><pre><code>OrderController : path=\"/order\", GET : create()\nUserController  : path=\"/user\",  GET : signup()\n</code></pre> When a request comes in, Spring checks in the Handler Mappings:</p> <ul> <li>If a match is not found : 404 Not Found</li> <li>If a match is found : The respective controller method is executed</li> </ul> Step 3: Request Handling <ul> <li>The Handler (Controller method) processes the request.</li> <li> <p>It may return:</p> <ul> <li>Data (JSON/XML) \u2192 in REST APIs (@ResponseBody)</li> <li>Logical view name (for web apps with JSP/Thymeleaf)</li> </ul> </li> </ul> Step 4: View Resolver <ul> <li>If the controller returns a view name, the <code>ViewResolver</code> maps it to an actual view file.</li> <li>Controller returns \"index\" (a logical view name).</li> <li>Spring adds the prefix + suffix: <code>/WEB-INF/view/ + index + .jsp</code> \u2192 <code>/WEB-INF/view/index.jsp</code></li> <li>Then, the view layer (JSP/Thymeleaf/HTML) is rendered and returned to the client.</li> </ul> <p></p> <p>Summary Flow</p> <ul> <li>Request \u2192 DispatcherServlet (Front Controller)</li> <li>DispatcherServlet \u2192 Handler Mapping (finds matching controller method)</li> <li>Controller Method executes (returns data or view name)</li> <li>DispatcherServlet \u2192 ViewResolver (resolves actual view)</li> <li>Response sent back to client   </li> </ul> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/6-monolithic-architecture/","title":"Monolithic Architecture: Frontend and Backend in the Same Layer","text":"1. Add View Layer <p>Inside your src/main folder, create the following structure:</p> <pre><code>src/main/webapp\n \u2514\u2500\u2500 WEB-INF\n      \u2514\u2500\u2500 view\n           \u2514\u2500\u2500 index.jsp\n</code></pre> 2. Configure View Resolver <p>In <code>application.properties</code>, tell Spring where to look for JSP files:</p> <pre><code>spring.mvc.view.prefix=/WEB-INF/view/\nspring.mvc.view.suffix=.jsp\n</code></pre> <p>So, if a controller returns \"index\", Spring looks for /WEB-INF/view/index.jsp.</p> 3. Implement MVC Architecture <ul> <li>Controller : handles request</li> <li>View : JSP page for UI</li> <li>Model : data passed between controller and view</li> </ul> 4. Add Tomcat JSP Support <ul> <li>By default, embedded Tomcat in Spring Boot does not support JSP.</li> </ul> <p>so add dependency ,also need JSTL (Java Standard Tag Library):</p> <pre><code>   &lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n       &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;\n       &lt;version&gt;11.0.7&lt;/version&gt;\n   &lt;/dependency&gt;\n\n   &lt;!-- JSTL Support --&gt;\n   &lt;dependency&gt;\n       &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;\n       &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;\n       &lt;scope&gt;provided&lt;/scope&gt;\n   &lt;/dependency&gt;\n</code></pre> <p></p> <p>\u2191 Back to top </p>"},{"location":"spring-boot/web-mvc/7-requestmapping-getmapping/","title":"4.7 RequestMapping and @GetMapping","text":"RequestMapping and @GetMapping @RequestMapping <ul> <li>Can handle all HTTP methods (GET, POST, PUT, DELETE)</li> <li>Syntax: <code>@RequestMapping(value=\"/path\", method=RequestMethod.GET)</code></li> </ul> @GetMapping <ul> <li>Handles GET requests only</li> <li>Syntax: <code>@GetMapping(\"/path\")</code></li> <li>Simpler and cleaner for GET requests</li> </ul> <p>Example:</p> <pre><code>    @Controller\n    public class HomeController {\n\n       @RequestMapping(value=\"/home\", method=RequestMethod.GET)\n        public String home() { return \"index\";}\n\n        @GetMapping(\"/home\")\n        public String home() {  return \"index\";}\n\n    }\n</code></pre>"},{"location":"spring-boot/web-mvc/8-ModelAndView/","title":"4.8 ModelAndView","text":"ModelAndView <p>Combines model and view in one object.</p> <p>ModelAndView is a Spring MVC class used to return both:</p> <ul> <li>Model (data) : data that send to the view (like variables/messages).</li> <li>View (page) : the name of the view (JSP, Thymeleaf, etc.) to render.</li> </ul> <p><pre><code> @RequestMapping(path = \"/account/login\", method = RequestMethod.POST)\n    public ModelAndView handleUserRegistration() {\n\n        ModelAndView mav = new ModelAndView();\n        mav.setViewName(\"login\");  //login.jsp\n        mav.addObject(\"message\", msg); // \n        return mav;\n    }\n</code></pre> Login.jsp <pre><code>    &lt;h1&gt;Login Page &lt;/h1&gt;\n    &lt;h2&gt;${message}&lt;/h2&gt;\n</code></pre></p>"},{"location":"spring-boot/web-mvc/9-SOAP-vs-REST/","title":"4.9 SOAP vs REST","text":"SOAP (Simple Object Access Protocol) <ul> <li>Protocol: A strict communication <code>protocol</code>.</li> <li>Format:<code>Always XML</code> (SOAP messages are wrapped inside an ). <li>Transport: Usually HTTP, but can also use SMTP, TCP, etc.</li> <li>Standards: Has built-in rules for security (WS-Security), transactions, error handling.</li> <li>State: Stateful or Stateless.</li> <li>Tight coupling: Requires both client and server to strictly follow WSDL (Web Services Description Language).</li> REST (Representational State Transfer) <ul> <li><code>Architecture style</code> (not a protocol).</li> <li>Format: Can use <code>JSON</code>, XML, HTML, or plain text (JSON is most common).</li> <li>Transport: Always uses <code>HTTP</code> (GET, POST, PUT, DELETE).</li> <li>Stateless: Each request contains all necessary info (server doesn\u2019t remember client state).</li> <li>Lightweight &amp; flexible compared to SOAP.</li> </ul>"},{"location":"spring-framework/1-spring-intro/","title":"1. Introduction","text":"Introduction"},{"location":"spring-framework/1-spring-intro/#what-is-spring","title":"What is Spring?","text":"<ul> <li>Spring is a Dependency Injection framework to make Java applications loosely coupled.</li> <li>Makes the development of <code>JavaEE</code> applications easier.</li> </ul>"},{"location":"spring-framework/1-spring-intro/#what-is-reflection-api","title":"What is Reflection API?","text":"<ul> <li>Allows inspect and manipulate classes, methods, fields, constructors at runtime.</li> <li>Can work without knowing names at compile time.</li> <li>Part of package: <code>java.lang.reflect</code>.</li> <li>Key classes: <code>Class</code>, <code>Method</code>, <code>Field</code>, <code>Constructor</code>, <code>Modifier</code>.</li> <li>Used in frameworks like Spring, Hibernate, JUnit for dynamic behavior.</li> </ul> <p>Example <pre><code>@Autowired\nprivate Address address;\n</code></pre> field injection with <code>@Autowired</code> is powered by Reflection API.</p> <p>Reflection = Runtime inspection + manipulation of classes and objects.</p>"},{"location":"spring-framework/1-spring-intro/#spring-standalone-collection","title":"Spring Standalone Collection","text":"<ul> <li>A collection (List, Set, Map, or Properties) managed by Spring.</li> <li>Injected into a Spring bean via XML or Java configuration.</li> <li>Standalone means it is defined directly in Spring, without external frameworks.</li> <li>Useful for storing multiple values and injecting them into beans.</li> </ul>"},{"location":"spring-framework/1-spring-intro/#transitive-dependency-in-java","title":"Transitive dependency in JAVA","text":"<p>A transitive dependency is an indirect dependency included in a project because a direct dependency requires it.</p> <p>Direct dependency : declared explicitly.</p> <p>Transitive dependency : pulled in through another dependency.</p> <ol> <li> <p>Maven Example:</p> <p><code>Project \u2192 Library A \u2192 Library B</code></p> <p>Here, Library B is a transitive dependency.</p> </li> <li> <p>In Spring</p> <p><code>spring-core \u2192 depends on \u2192 spring-jcl.</code></p> <p>if we download spring-core jar file then maven automatically also download spring-jcl jar file. </p> </li> </ol> <p></p> <p>\u2191 Back to top</p>"},{"location":"spring-framework/10-inject-primitive/","title":"10. Inject Primitive and String Type","text":"Inject Primitive and String Type"},{"location":"spring-framework/10-inject-primitive/#1-application-properties","title":"1. Application Properties","text":"<ul> <li>Always configuring data which is commonly being used by all spring Beans.</li> <li>Called as Configuration file.</li> <li>key value pair format(key-val).</li> <li>two types of properties<ul> <li>pre-defiend(spring.application.name)</li> <li>used defiend(db.name=alamgir)</li> </ul> </li> </ul> <p>Example <code>application.properties</code> file:</p> <pre><code>spring.application.name=b-dependency-injection\ndb.port=8080\ndb.url=localhost:8080\ndb.password=mysql\ndb.database=mysql,oracle,postgres\n</code></pre>"},{"location":"spring-framework/10-inject-primitive/#2-using-value-annotation","title":"2. Using @Value Annotation","text":"Injecting values directly: <pre><code>@Value(\"8080\")\nprivate int port;\n\n@Value(\"localhost:8080\")\nprivate String url;\n</code></pre> Injecting from properties: <pre><code>@Value(\"${db.password}\")\nprivate String password;\n</code></pre> Default Values <p><pre><code>@Value(\"${db.name:mysql}\")\nprivate String name;\n</code></pre> If the property is missing, the default value <code>mysql</code> will be used.</p> Injecting Multiple Values <p>For list-type properties:</p> <pre><code>@Value(\"${db.database}\")\nprivate List&lt;String&gt; database;\n</code></pre> <p>If <code>db.database=mysql,oracle,postgres</code> : it becomes a list: <code>[mysql, oracle, postgres]</code></p> <p>How it works:</p> <ol> <li>Spring checks <code>application.properties</code> (or <code>application.yml</code>).</li> <li>Looks for the property.<ul> <li>If  Found : proceeds.</li> <li>If Not found : throws <code>java.lang.IllegalArgumentException: Could not resolve placeholder 'db.password'.</code></li> </ul> </li> <li>Injects the value into the field.</li> </ol>"},{"location":"spring-framework/10-inject-primitive/#3-using-propertysource","title":"3. Using @PropertySource","text":"<p>Add external <code>.properties</code> files:</p> <pre><code>@Configuration\n@PropertySource(\"classpath:db.properties\")\npublic class AppConfig { }\n</code></pre>  Key Points <ul> <li><code>@PropertySource</code> tells Spring where to load a <code>.properties</code> file from.</li> <li>Used on  a @Configuration class.</li> <li>Works with <code>@Value(\"${property.name}\")</code>.</li> <li>Can load multiple files:     <pre><code>@Configuration\n@PropertySource(\"classpath:db.properties\")\npublic class AppConfig { }  \n</code></pre> <code>classpath:</code> looks inside <code>src/main/resources</code>.</li> <li> <p>If a property exists in both <code>application.properties</code> and a <code>@PropertySource</code> file:</p> <ul> <li>Spring Boot uses the value from application.properties.</li> <li><code>@PropertySource</code> has lower priority than default Spring Boot property files.</li> </ul> <p>\u2191 Back to top</p> <p>Github Code : Inject primitives and String type : Spring Boot</p> </li> </ul>"},{"location":"spring-framework/11-bean-scope/","title":"Spring Bean Scopes Points to remember","text":"<ul> <li>In Spring Framework, bean scopes define the lifecycle and visibility of beans in the Spring IoC container.</li> <li><code>@Scope</code> defines a bean's lifecycle and visibility of the bean.</li> </ul> Common @Scope Values <ol> <li> <p>singleton( by default)</p> <ul> <li>Only one instance of the bean per Spring container.</li> <li>Same object is shared everywhere.</li> <li>This is the default scope if no other scope is specified.</li> <li><code>Lifecycle</code>: The bean is created when the application context is initialized and destroyed when the context is destroyed.    </li> </ul> </li> <li> <p>prototype</p> <ul> <li>A new instance is created every time the bean is requested.9</li> <li><code>Lifecycle</code>: Created every time requested, not managed by Spring after that.    </li> </ul> </li> <li> <p>request (Web-aware only)</p> <ul> <li>One bean instance per HTTP request.</li> <li>Used in web applications (Spring MVC).</li> <li><code>Lifecycle</code>: Created for each HTTP request, destroyed at request end    </li> </ul> </li> <li> <p>session(Web-aware only)</p> <ul> <li>One bean instance per HTTP session.</li> <li><code>lifecycle</code>: Created for each HTTP session, destroyed when session ends  </li> </ul> </li> <li> <p>application (Web-aware only)</p> <ul> <li>One bean instance per ServletContext (entire web app).</li> <li>Similar to singleton but specific to web context.</li> <li><code>Lifecycle</code>: Created when ServletContext is initialized, destroyed at shutdown.    </li> </ul> </li> <li> <p>websocket(Web-aware only, since Spring 4.2)</p> <ul> <li>One bean instance per WebSocket session.</li> <li><code>Lifecycle</code>: Created when WebSocket session is established, destroyed at session end</li> </ul> </li> </ol> <p>Example:</p> XMLAnnotation <pre><code>&lt;bean id=\"myBean\" class=\"com.example.MyBean\" scope=\"prototype\"/&gt;\n</code></pre> <pre><code>@Component            // stereotype (registers the bean)\n@Scope(\"prototype\")   // modifies its lifecycle(Define the scope as prototype)\npublic class MyBean { \n   //Bean defination\n}\n</code></pre> <ul> <li>@Scope is applied at the class level.</li> <li>Affects the Spring-managed bean, not the class itself.</li> <li>Each bean (even from the same class) can have a different scope.</li> <li>Does not apply globally to the class \u2014 only to the specific bean definition.</li> </ul> Example Code <pre><code>@Configuration\npublic class AppConfig {\n\n   @Bean\n   @Scope(\"singleton\")  // First bean with singleton scope\n   public MyBean singletonBean() {\n      // This scope applies only to the Spring-managed bean of singletonBean\n      return new MyBean();\n   }\n\n   @Bean\n   @Scope(\"prototype\")  // Second bean with prototype scope\n   public MyBean prototypeBean() {\n      // This scope applies only to the Spring-managed bean of prototypeBean\n      return new MyBean();\n   }\n}\n</code></pre> <p></p> <p>\u2191 Back to top</p> <p>Github Code : Bean Scope : Spring</p>"},{"location":"spring-framework/12-life-cycle-method/","title":"12. Spring Bean Life Cycles","text":"Spring Bean Life Cycles"},{"location":"spring-framework/12-life-cycle-method/#1-what-is-spring-bean-lifecycle","title":"1. What is  Spring Bean Lifecycle?","text":"<ul> <li>Lifecycle of an individual bean managed by the container.</li> <li>key annotation : <code>@PostConstruct</code>, <code>@PreDestroy</code>, <code>InitializingBean</code>, etc.</li> <li>Includes : Instantiation, Dependency Injection, Init &amp; destroy callbacks.</li> </ul>"},{"location":"spring-framework/12-life-cycle-method/#2-life-cycle-method","title":"2. Life Cycle Method","text":"<ol> <li>Instantiation \u2013 Spring creates the bean object.</li> <li>Populate properties / Dependency Injection \u2013 Spring injects values or references.</li> <li>BeanNameAware / BeanFactoryAware callbacks \u2013 Optional callbacks if implemented.</li> <li>Pre-initialization \u2013 <code>@PostConstruct</code> or<code>afterPropertiesSet()</code> (from InitializingBean).</li> <li>Custom init method \u2013 Optional method defined by <code>init-method</code>.</li> <li>Bean is ready to use \u2013 Application uses the bean.</li> <li>Destruction \u2013 Container shuts down; <code>@PreDestroy</code>, <code>destroy()</code> (from <code>DisposableBean</code>), or <code>destroy-method</code> is called.         </li> </ol>"},{"location":"spring-framework/12-life-cycle-method/#3-ways-to-define-lifecycle-methods","title":"3. Ways to Define Lifecycle Methods","text":"<p>1. Using xml</p> <ul> <li>Spring provide two method to every bean .</li> <li>Good for 3rd-party or external classes.</li> <li>we can change the name of these method but signature must be same<ul> <li><code>public void init()</code>: Called after creation via config.Initialization code loading config,connecting db,webservice .</li> <li><code>public void distroy()</code>:For clean up code</li> </ul> </li> </ul> Example Code <pre><code>&lt;bean id=\"student\" class=\"Student\" init-method=\"init\" destroy-method=\"cleanup\"/&gt;\npublic class Student {\n\n   public void init() {\n      System.out. println(\"Bean is initialized\");\n   }\n   public void cleanup() {\n      System.out.println(\"Bean is destroyed\");\n   }\n\n}\n</code></pre> <p>2. Using Interface</p> <ul> <li><code>afterPropertiesSet()</code> : called after dependencies are injected.</li> <li><code>destroy()</code> : called when container shuts down.</li> </ul> Example Code <pre><code>@Component\n public class Student implements InitializingBean, DisposableBean {\n\n            @Override\n            public void afterPropertiesSet() throws Exception {\n               System.out.println(\"Bean is initialized\");\n            }\n\n            @Override\n            public void destroy() throws Exception {\n               System.out.println(\"Bean is destroyed\");\n       }\n    }\n</code></pre> <p>3. Using Annotation</p> <ul> <li>Recommended modern approach</li> <li><code>@PostConstruct</code> : Called after bean is created &amp; dependencies injected</li> <li><code>@PreDestroy</code> : called before bean is removed from container.</li> </ul> Example Code <pre><code>@Component\npublic class Student {\n         public Student(){}\n         @PostConstruct\n         public void init() {\n            System.out.println(\"Bean is initialized\");\n         }\n\n         @PreDestroy\n         public void cleanup() {\n            System.out.println(\"Bean is destroyed\");\n         }\n\n         public void init2(){\n            System.out.println(\"Bean is initialized again\");\n         }\n\n         public void cleanup2() {\n            System.out.println(\"Bean is destroyed again\");\n     }\n }\n\n\npublic class AppConfig{\n   @Bean(initMethod = \"init2\", destroyMethod = \"cleanup2\")\n   public Student student2(){\n      return new Student();\n   }\n}\n</code></pre> <p>All 4 methods will be called, in this order:</p> <ol> <li>Initialization Order (on startup):</li> <li><code>@PostConstruct</code> : <code>init()</code></li> <li> <p><code>@Bean(initMethod = \"...\")</code> : <code>init2()</code></p> </li> <li> <p>Destruction Order (on shutdown):</p> <ul> <li><code>@PreDestroy</code> : <code>cleanup()</code></li> <li><code>@Bean(destroyMethod = \"...\")</code> : <code>cleanup2()</code></li> </ul> </li> </ol>"},{"location":"spring-framework/12-life-cycle-method/#4-question","title":"4. Question","text":"<p>1. Is it possible to execute logic when a bean object created?</p> <p>YES,Ways to Execute Logic After Bean Creation:</p> <ul> <li><code>init-method</code>in XML or <code>@Bean</code></li> <li><code>@PostConstruct</code> using annotation</li> <li><code>InitializingBean.afterPropertiesSet()</code> using interface</li> </ul> <p>2. Difference Between singleton and prototype scope (Bean Lifecycle Perspective)</p> <ol> <li> <p>Singleton</p> <ul> <li>Created once at container startup</li> <li><code>@PreDestroy</code> / <code>destroy()</code> : Called by Spring when context is closed</li> <li>Bean Destruction Responsibility : Spring container</li> </ul> </li> <li> <p>Prototype</p> <ul> <li>Created every time the bean is requested.</li> <li><code>@PreDestroy</code> / <code>destroy()</code>: Not called automatically</li> <li>Bean Destruction Responsibility : must be handle manually.</li> </ul> </li> </ol> <p></p> <p>\u2191 Back to top</p> <p>Github Code : Bean Life Cycle : Spring </p>"},{"location":"spring-framework/13-spring-jdbc/","title":"13. Spring JDBC","text":"Spring JDBC"},{"location":"spring-framework/13-spring-jdbc/#1-jdbc-java-database-connectivity","title":"1. JDBC (Java Database Connectivity)","text":"<p>A powerful mechanism to connect to the database and execute SQL queries.</p>"},{"location":"spring-framework/13-spring-jdbc/","title":"Problems with JDBC","text":"<ul> <li>A lot of boilerplate code.</li> <li>Exception Handling Problem (multiple try-catch-finally block).</li> <li>Code duplication.</li> <li>Database login is a time consuming task.</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#2-spring-jdbc","title":"2. Spring JDBC","text":"<ul> <li>Provides a JDBC abstraction layer through the JdbcTemplate class.</li> <li>Simplifies JDBC code with less boilerplate.</li> <li>Provides jdbcTemplate class which has all the important methods to perform operations with database.</li> <li>Integrates easily with Spring\u2019s IoC container (dependency injection).</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"Key Components","text":""},{"location":"spring-framework/13-spring-jdbc/","title":"1. DataSource","text":"<ul> <li>Interface type</li> <li>Used to manage database connection properties (username, password, url).</li> <li>Contains:<ul> <li><code>driverClassName</code> = ? (for MySql \u2192 com.mysql.jdbc.Driver)</li> <li><code>url</code> = ? (jdbc:localhost:8080)</li> <li><code>username</code> = ?</li> <li><code>password</code> = ?</li> </ul> </li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"2. DriverManagerDataSource","text":"<ul> <li>Implementation of DataSource</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#3-jdbctemplate","title":"3. JdbcTemplate","text":"<p>JdbcTemplate is a Spring Framework class that simplifies interaction with relational databases.</p> <ul> <li>Pre-defined and Bean type class.</li> <li>It is created using an <code>@Bean</code> method (not with <code>@Component</code>, since it\u2019s a predefined Spring class).</li> <li>Helper class for simpler JDBC database access.</li> <li>Removes boilerplate (connection, statement, resultset handling).</li> <li>Converts SQLExceptions to Spring\u2019s DataAccessException.</li> <li>Automatically manages resource closing and exception translation.</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"Common Methods in JdbcTemplate","text":"<ul> <li><code>update()</code> : INSERT, UPDATE, DELETE</li> <li><code>query()</code> : SELECT returning multiple rows</li> <li><code>queryForObject()</code> : SELECT returning a single row/value</li> <li><code>batchUpdate()</code> : Bulk operations</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#4-manually-jdbctemplate-configuration-spring","title":"4. Manually JdbcTemplate Configuration (Spring)","text":"<ul> <li>Manually create Bean objects.</li> <li>JdbcTemplate defined in a Configuration class with an <code>@Bean</code> method.</li> <li>DataSource configured with url, username, and password.</li> <li>Use JdbcTemplate: Predefined classes exposed via <code>@Bean</code>, not <code>@Component</code>.</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"Steps to Use","text":"<ul> <li>Create and configure <code>DriverManagerDataSource</code> (set driver class, DB URL, username, and password)</li> <li>Inject DataSource into <code>JdbcTemplate</code></li> <li>Use JdbcTemplate to perform database operations (<code>query()</code>, <code>update()</code>, <code>execute()</code>, etc.)</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#5-jdbctemplate-configuration-in-spring-boot","title":"5. JdbcTemplate Configuration in Spring Boot","text":"<ul> <li>Auto-configuration enabled by <code>@SpringBootApplication</code> (includes <code>@EnableAutoConfiguration</code>).</li> <li>Add dependency: <code>spring-boot-starter-jdbc</code>.</li> <li>JDBC driver (jar) added to classpath via dependency automatically.</li> <li>JdbcTemplate Bean auto-created using <code>spring.datasource.*</code> and taking properties (url, username, password) from <code>application.properties</code> file.</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"Steps to Use","text":"<p>Using JDBC in Spring Boot</p> <ul> <li>Add JDBC driver:  (<code>Oracle: ojdbc</code>,<code>MySQL: MySQL connector</code>, <code>PostgreSQL: pg jar</code>).</li> <li>Configure database in <code>application.properties</code> (URL, username, password, driver).</li> <li>Use <code>JdbcTemplate</code> for queries: query(), queryForObject(), update(), batchUpdate().</li> <li>Resource management is automatic (connections opening and closing , exceptions handled by Spring).</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#6-what-is-resultset","title":"6. What is ResultSet?","text":"<ul> <li>A Java object that represents the data returned from a SQL query.</li> <li>Created when executing a SELECT statement.</li> <li>Acts like a cursor that points to rows in the result.</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/","title":"Common Methods","text":"<ul> <li><code>next()</code> : Move to next row (returns true if row exists)</li> <li><code>getString(\"columnName\")</code> : Get column value as String</li> <li> <p><code>getInt(\"columnName\")</code> : Get column value as int</p> </li> <li> <p><code>getDate(\"columnName\")</code> : For other types</p> </li> <li><code>close()</code> : Free the ResultSet resources</li> </ul>"},{"location":"spring-framework/13-spring-jdbc/#7-rowmapper","title":"7. RowMapper","text":"<ul> <li><code>RowMapper&lt;T&gt;</code> is a Spring interface.</li> <li>It maps each row of a ResultSet into a Java object (T).</li> <li>Makes code cleaner by avoiding direct ResultSet handling.</li> <li>Commonly used with <code>JdbcTemplate.query()</code> and <code>queryForObject()</code>.</li> <li>Example: Convert rows from <code>studentTable</code> into <code>Student</code> objects</li> </ul> <p>The Interface</p> <pre><code>public interface RowMapper&lt;T&gt; {\n    T mapRow(ResultSet rs, int rowNum) throws SQLException;\n}\n</code></pre> <ul> <li><code>rs</code> : current row of the ResultSet</li> <li><code>rowNum</code> : row number (starting from 0)</li> <li>Returns : the mapped object (e.g., a Student object)</li> </ul> <p>1.For single Object: <code>public queryForObject(String sql,RowMapper&lt;T&gt; rowMapper,Object args)</code></p> <pre><code>    Student student = jdbcTemplate.queryForObject(\n        \"SELECT * FROM studentTable WHERE id=?\",\n        new StudentRowMapper(),\n        id\n    );\n</code></pre> <p>2.For multiple Objects: <code>public List&lt;T&gt;query(String sql,RowMapper&lt;T&gt;rowMapper)</code></p> <pre><code>    List&lt;Student&gt; students = jdbcTemplate.query(\n        \"SELECT * FROM studentTable\",\n        new StudentRowMapper()\n    );\n</code></pre>"},{"location":"spring-framework/13-spring-jdbc/#8-what-is-beanpropertyrowmapper","title":"8. What is BeanPropertyRowMapper?","text":"<ul> <li>A built-in implementation of RowMapper.</li> <li>Automatically maps columns in a ResultSet to Java object fields (POJO).</li> <li>Uses JavaBean property naming (setters/getters).</li> </ul> <p><pre><code>class Student{\n    private int id ;\n    private String name;\n    // setters and getters methods\n}\n\n@Component\nclass Operation{\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    public void readAll(){\n        List&lt;Student&gt; students = jdbcTemplate.query(\n            \"SELECT * FROM studentTable\",\n            new BeanPropertyRowMapper&lt;&gt;(Student.class)\n        );\n    }\n\n}\n</code></pre> </p> <p>\u2191 Back to top</p> <p>Github Code : Spring JDBC : spring  </p> <p>Github Code : Spring JDBC : spring Boot </p>"},{"location":"spring-framework/2-spring-modules/","title":"2. Spring Framework Modules","text":"Spring Framework Modules"},{"location":"spring-framework/2-spring-modules/#1-core-container-layer","title":"1. Core Container Layer","text":"<ul> <li> <p>1. core:  </p> <ul> <li>Consists of the Core, Beans, Context, and SpEL modules.  </li> <li>Provides the core functionality (IoC, Dependency Injection).</li> </ul> </li> <li> <p>2. beans:  </p> <ul> <li>Manages beans (objects) and their life cycle.  </li> <li>A complex implementation of the factory pattern provided by the Bean module.</li> </ul> </li> <li> <p>3. Context:  </p> <ul> <li>Builds on Core and Beans modules.  </li> <li>Provides access to configured objects (beans).  </li> <li>Main entry point: ApplicationContext interface for dependency injection.</li> </ul> </li> <li> <p>4. SpEL (Spring Expression Language):  </p> <ul> <li>Expression language for searching/querying/manipulating objects at runtime.  </li> <li>Supports:<ul> <li>Property access  </li> <li>Method calls  </li> <li>Array/collection access  </li> <li>Variable use  </li> <li>Bean retrieval from IoC container  </li> </ul> </li> </ul> </li> </ul>"},{"location":"spring-framework/2-spring-modules/#2-aop","title":"2. AOP","text":"<ul> <li>Provides AOP (Aspect Oriented Programming) features.</li> </ul>"},{"location":"spring-framework/2-spring-modules/#3-aspect","title":"3. Aspect","text":"<ul> <li>A module that encapsulates cross-cutting logic.  </li> <li>Example: A logging aspect that runs before/after methods.</li> </ul>"},{"location":"spring-framework/2-spring-modules/#4-instrumentation","title":"4. Instrumentation","text":"<ul> <li>Provides class instrumentation and classloader implementations for certain servers.  </li> <li>Configurable via:</li> <li>XML  </li> <li>Annotations (<code>@Aspect</code>, <code>@Before</code>, <code>@After</code>, etc.)  </li> <li>AspectJ integration</li> </ul>"},{"location":"spring-framework/2-spring-modules/#5-messaging","title":"5. Messaging","text":"<ul> <li>Used for asynchronous communication between applications/components.  </li> <li>Supports:</li> <li>Point-to-point (Queue)  </li> <li>Publish-subscribe (Topic) models  </li> <li>Spring provides spring-jms for Java Messaging Service.</li> </ul>"},{"location":"spring-framework/2-spring-modules/#6-data-access-integration-layer","title":"6. Data Access / Integration Layer","text":"1. JDBC (Java Database Connectivity) <ul> <li>Contains a JDBC abstraction layer.  </li> <li>Simplifies JDBC code with less boilerplate.</li> </ul> 2. ORM (Object-Relational Mapping) <ul> <li>Integrates with ORM frameworks:</li> <li>Hibernate  </li> <li>JPA  </li> <li>JDO  </li> <li>iBatis  </li> <li>Supports declarative transactions for data persistence.</li> </ul> 3. OXM (Object/XML Mapping) <ul> <li>Supports mapping using:</li> <li>JAXB  </li> <li>Castor  </li> <li>XMLBeans  </li> <li>JiBX  </li> <li>XStream</li> </ul> 4. JMS (Java Messaging Service) <ul> <li>Provides features for producing/consuming or sending/receiving messages.</li> </ul> 5. Transaction <ul> <li>Supports programmatic and declarative transaction management for POJOs.</li> </ul>"},{"location":"spring-framework/2-spring-modules/#7-web-layer","title":"7. Web Layer","text":"<ul> <li>1. web: Basic web-oriented features (multipart file upload, REST clients).  </li> <li>2. Web-Servlet: MVC (Model View Controller) implementation for web applications.  </li> <li>3. Web-Portlet: MVC implementation for portlet environments; similar to Web-Servlet.  </li> <li>4. websocket: WebSocket and real-time communication support.  </li> <li>5. Web-Struts: Deprecated support for integrating Struts. Use Struts 2.0 or Spring MVC.</li> </ul>"},{"location":"spring-framework/2-spring-modules/#8-test-layer","title":"8. Test Layer","text":"<ul> <li>Supports testing Spring components with JUnit/TestNG.  </li> <li>Provides: Applica </li> </ul> <p>\u2191 Back to top</p>"},{"location":"spring-framework/3-pojo-vs-bean/","title":"3. Pojo and Bean","text":"POJO vs Bean <p>POJO (Plain Old Java Object) - A simple Java object, not bound by any special restrictions or frameworks. - Can have fields, getters/setters, and methods.</p> <p>Bean - A POJO managed by the Spring IoC container. - Instantiated, configured, and injected by Spring.</p> <p>All Spring beans are POJOs, but not all POJOs are Spring beans.</p>"},{"location":"spring-framework/4-ioc-container/","title":"4. IoC Container","text":"IoC Container"},{"location":"spring-framework/4-ioc-container/#1-ioc-container","title":"1. IoC Container","text":"<p>IoC(Inversion of Control) : Let the framework control object creation and wiring instead of the application itself.</p> <p>Responsible for: </p> <ul> <li>Bean Creation: Responsible for instantiating, configuring, and assembling beans.</li> <li>Bean Lifecycle Management: Manages the lifecycle of bean(objects).</li> <li>Dependency Injection: Injecting dependencies(bean) into other beans. </li> </ul> <p>Key Points:</p> <ul> <li>Enable loosely coupled applications,     where objects do not need to know about how their dependencies are created.    </li> <li>Implements <code>IoC</code> through <code>DI</code> to provide dependencies at runtime.</li> <li>primarily represented by the <code>ApplicationContext</code>.</li> </ul>"},{"location":"spring-framework/4-ioc-container/#2-types-of-ioc-container","title":"2. Types of IoC Container","text":"<ol> <li><code>BeanFactory</code><ul> <li>An interface type.</li> <li>Lazily loads beans (creates them only when requested).</li> <li>Provides basic dependency injection.</li> </ul> </li> <li><code>ApplicationContext</code><ul> <li>An interface type.</li> <li>Extends BeanFactory with more features.</li> <li>Supports Internationalization (i18n),Event propagation,Bean post-processing,Access to resources (files, URLs).</li> </ul> </li> </ol>"},{"location":"spring-framework/4-ioc-container/#3-types-of-applicationcontext-subclasses","title":"3. Types of ApplicationContext subclasses","text":"<ol> <li><code>ClassPathXmlApplicationContext</code> \u2013 Load Context from XML in classpath.</li> <li><code>FileSystemXmlApplicationContext</code> \u2013 XML from file system.</li> <li><code>AnnotationConfigApplicationContext</code> \u2013 Java-based config using annotation(<code>@Configuration</code>).</li> <li><code>WebApplicationContext</code> \u2013 For web apps integrating with Spring MVC.</li> <li><code>GenericApplicationContext</code> \u2013 Flexible,can combine XML ,annotation and programmatic Configuration.</li> </ol> <p>Responsible for: - Loads <code>Config.xml</code>  - Reads bean definitions - Creates &amp; initializes beans inside Spring container</p> <p>Example  </p> <pre><code> ApplicationContext container= new ClassPathXmlApplicationContext(\"Config.xml\");\n</code></pre> <p>What actually happens:</p> <ul> <li>Reads Config.xml.</li> <li>Finds bean definitions (classes you declared with  or via annotations like @Component).<ul> <li>Duplicate bean id : Exception (duplicate bean IDs not allowed).</li> <li>Requesting undefined bean id : Exception (bean not found in config).</li> <li>(Reference of other bean)passing id of other class : bean is matching but data type is not matching. </li> </ul> <li>For each bean definition<ul> <li>Checks if the class exists in the classpath.</li> <li>If it exists, Spring creates an object (bean).</li> <li>If it\u2019s missing, it throws an error at startup. </li> </ul> </li> <p>so Spring only checks &amp; creates objects for the configured beans, not for every class in our project.</p>"},{"location":"spring-framework/4-ioc-container/#4-ioc-container-lifecycle","title":"4. IoC Container Lifecycle","text":"<ul> <li>Lifecycle of the Spring container itself (e.g. <code>ApplicationContext</code>).</li> <li>Scope is Global : affects the entire application context.</li> <li>Includes : Context creation,Event publishing,Bean loading,Shutdown handling.</li> <li>Key annotations/APIs:<code>ApplicationListener</code>, <code>ContextRefreshedEvent</code>, etc.</li> <li>Managed by : Spring framework at the container level.</li> </ul> <p>Life Cycle Method </p> <ol> <li>Initialization: Container starts, reads configuration, and loads bean definitions.</li> <li>Bean Instantiation: Creates bean objects using constructors or factory methods.</li> <li>Dependency Injection (DI): Injects required dependencies into beans.</li> <li>Lifecycle Management: Calls <code>@PostConstruct</code> methods after initialization and <code>@PreDestroy</code> before destruction.</li> <li>Singleton Scope:** By default, one instance per bean is maintained in the container.</li> <li>ApplicationContext Events: Publishes events that components can listen to for loosely coupled, event-driven design.</li> <li>Bean Post-Processing: BeanPostProcessors can modify beans before and after initialization.</li> </ol> <p></p> <p>\u2191 Back to top</p>"},{"location":"spring-framework/5-dependency-injection/","title":"5. Dependency Injection","text":"Dependency Injection"},{"location":"spring-framework/5-dependency-injection/#what-is-dependency-injection-di","title":"What is Dependency Injection (DI)?","text":"<p>A design pattern where an object\u2019s dependencies are provided (injected)by an external source rather than the object creating them itself.</p> <p>Example of dependencies:</p> <ul> <li>A <code>car</code> depends on an engine and tires.</li> <li>A <code>smartphone</code> depends on a battery and a screen.</li> </ul>"},{"location":"spring-framework/5-dependency-injection/#how-is-it-related-to-ioc","title":"How is it related to IoC?","text":"<p>DI is the implementation of IoC in Spring; the IoC container injects dependencies into beans automatically.</p> <p>Example</p> <p><pre><code>Class A{\n    method1()\n    method2()\n}\nclass B{\n    A a; //non-static variable\n    a.method1()\n}\n</code></pre> What happend?</p> <ul> <li>Class A : Contains <code>method1()</code> and <code>method2()</code>.</li> <li>Class B : Contains a non-static variable <code>A a</code> and calls <code>a.method1().</code></li> <li>Spring Framework : Receives information about A and B, identifies that B depends on A, creates an instance of A internally, and injects it into B.</li> </ul>"},{"location":"spring-framework/5-dependency-injection/#types-of-dependency-injection","title":"Types of Dependency Injection","text":"<ul> <li>Constructor Injection: provided via the class constructor.</li> <li>Setter/property Injection: provided via setter methods.</li> <li>Field Injection: injected directly into fields using annotations (<code>@Autowired</code>).</li> </ul> <p>The IoC Container in Spring handles mainly three types of dependencies</p> <ul> <li>Primitive values (int, float, String, etc.)</li> <li>Collection types (List, Set, Map, etc.)</li> <li>Reference types (objects of other beans/classes) </li> </ul> <p>\u2191 Back to top</p>"},{"location":"spring-framework/6-configuration-metadata/","title":"Configuration MetadataSpring XML DI Example - Project Procedure","text":"<p>Where we declare beans and it's dependency.The container knows what to instantiate and configure using configuration metadata .</p> <p>Three ways to Configuring Metadata</p> <ol> <li> <p>XML</p> <ul> <li>Beans and their dependencies are declared in an XML file (commonly <code>config.xml</code> or<code>applicationContext.xml</code>).</li> <li>Spring container reads the XML file and creates objects accordingly.</li> </ul> </li> <li> <p>Java annotations</p> <ul> <li>Done by annotating classes, methods, or fields.</li> <li>Use <code>@Component</code>,<code>@Autowired</code></li> <li><code>@Autowired</code> \u2013 Most common annotation; tells the IoC container to inject dependencies.</li> </ul> </li> <li> <p>Java code</p> <ul> <li><code>@Configuration</code> \u2013 Marks a class as a source for bean definitions.</li> <li><code>@Bean</code> \u2013 Indicates that a method\u2019s return object should be managed by the IoC container.</li> </ul> </li> </ol> <pre><code>class Student{\n        int id\n        String name\n       }\n</code></pre> <ol> <li>Create Maven Project : Set up project structure using Maven.</li> <li>Add Dependencies : Add Spring Core and Spring Context in <code>pom.xml</code>.</li> <li>Create Bean (<code>Student.java</code>) : Plain Old Java Object (POJO) with properties <code>id</code> and <code>name</code>.</li> <li> <p>Create Configuration File (<code>config.xml</code>) :Define the student1 bean and set properties. <pre><code>    &lt;bean id=\"student1\" class=\"com.core.Student\"&gt; &lt;/bean&gt;\n</code></pre></p> </li> <li> <p>Setter Injection : Use setter methods in <code>Student.java</code> to inject <code>id</code> and <code>name</code>.</p> </li> <li>Main Class :<ul> <li>Load Spring <code>ApplicationContext</code>.</li> <li>Retrieve Student bean and use it.</li> </ul> </li> </ol> <pre><code>       ApplicationContext container= new ClassPathXmlApplicationContext(\"Config.xml\");\n       Object obj =container.getBean(\"student1\");\n       Student s1=(Student)obj;\n</code></pre> <p>Key Points:</p> <p>Bean : An object managed by the IOC container.</p> <p>DI \u2013 Container injects dependencies.</p> <p>IoC \u2013 DI is Spring\u2019s way of implementing IoC. </p> <p></p> <p>\u2191 Back to top</p> <p>Github Code : Configuration Metadata</p>"},{"location":"spring-framework/7-di-xml/","title":"7. Dependency Injection via XML","text":"Dependency Injection via XML <p>Two ways to inject dependencies via XML</p> <ol> <li>Setter Injection</li> <li>Constructor Injection</li> </ol>"},{"location":"spring-framework/7-di-xml/#1-setter-injection","title":"1. Setter Injection","text":"<ul> <li>Dependencies are injected via setter methods after the bean is instantiated.</li> <li>Declared in XML with <code>property</code> tag</li> </ul> Setter Injection process: <ol> <li>Object is created using the default constructor.  </li> <li>Setter methods are called to inject values or references.  </li> <li>Default Constructor and Setter method must be specified.</li> </ol> <p>When Using:  </p> <pre><code>    &lt;property name=\"\" class=\"\"&gt;&lt;/property&gt; or \n    &lt;property name=\"\" ref=\"\"&gt;\n</code></pre> <ol> <li>Creates the object(bean).</li> <li>Identify the setter method for the property.</li> <li>Passes the value (or reference) to the setter and dependency is injected.</li> </ol> Supports <ol> <li>Attribute or p-schema injection</li> <li>Collections (List, Set, Map) injection</li> <li>Reference type (other beans) injection</li> </ol> Java FormatXML Format <pre><code>class Address {\n    private String email;\n    public void setEmail(String email) { this.email = email; }\n}\n\nclass Student {\n    private String name;\n    private Address address;   // Reference type\n    List&lt;String&gt; fruits;       // Collection type\n\n    public void setId(int id) { this.id = id; }\n    public void setName(String name) { this.name = name; }\n    public void setAddress(Address address) { this.address = address; }\n    public void setFruits(List&lt;String&gt; fruits) { this.fruits = fruits; }\n}\n</code></pre> <pre><code>&lt;!-- Attribute or p-schema injection --&gt;\n&lt;bean id=\"addressBean\" class=\"Address\" p:email=\"alamgir.ahosain@gmail.com\"/&gt;\n\n&lt;bean id=\"student1\" class=\"Student\"&gt;\n    &lt;property name=\"name\" value=\"Alamgir\"/&gt;\n    &lt;property name=\"address\" ref=\"addressBean\"/&gt; &lt;!-- Reference type injection --&gt;\n\n    &lt;property name=\"fruits\"&gt;\n        &lt;!-- Collections (List) injection --&gt;\n        &lt;list&gt;\n            &lt;value&gt;Mango&lt;/value&gt;\n            &lt;value&gt;Jack Fruit&lt;/value&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre> Scenario <pre><code>Class Address{}\nClass Home{}\nClass Student { \n    private Address address;\n    public void setAddress(Address address){ this.address = address; }\n}\n\n&lt;bean id=\"address\" class=\"Address\"&gt;&lt;/bean&gt;\n&lt;bean id=\"homeBean\" class=\"Home\"&gt;&lt;/bean&gt;\n&lt;bean id=\"student1\" class=\"Student\"&gt;\n    &lt;property name=\"address\" ref=\"homeBean\"/&gt;\n&lt;/bean&gt;\n</code></pre> <p>Question: What happens if a bean\u2019s ref points to another bean with a mismatched type?</p> <p>Two possible cases:</p> <ul> <li>Bean not found  : throws <code>NoSuchBeanDefinitionException</code></li> <li>Bean type mismatch : throws <code>BeanCreationException</code></li> </ul> <p>Question:</p> <pre><code>Class Student{}\n</code></pre> <ol> <li>Is it possible to create bean object or not? \u2192 YES</li> <li>Is it possible to do Setter Injection, Constructor Injection or both? \u2192 NO</li> </ol>"},{"location":"spring-framework/7-di-xml/#2-constructor-injection","title":"2. Constructor Injection","text":"<ul> <li>Constructor Injection provided via the class constructor.</li> <li>Object Creation and Injection happen at the same time.</li> <li>Constructor must be specified.</li> </ul>  Constructor Injection Process: <ol> <li>Object is created via a constructor with arguments (No need setters).</li> <li>Values or bean references are passed directly through the constructor.</li> </ol> <p>Ambiguity arises when multiple constructors exist with same argument types. Fix using :</p> <ol> <li>index : specify parameter position</li> <li>type : specify parameter type</li> <li>name : specify parameter name</li> </ol> ProblemSolutions <pre><code>public Student(String name, int id) {   // constructor 1\nthis.name = name;\nthis.id = id;\n}\npublic Student(int id, String name) {   // constructor 2\nthis.id = id;\nthis.name = name;\n}\n</code></pre> <pre><code>&lt;!-- 1. Use index(parameter position (0, 1, 2 \u2026).) --&gt;\n&lt;bean id=\"student\" class=\"Student\"&gt;\n    &lt;constructor-arg index=\"0\" value=\"Alamgir\"/&gt; &lt;!-- String first --&gt;\n    &lt;constructor-arg index=\"1\" value=\"12\"/&gt;   &lt;!-- int second --&gt;\n&lt;/bean&gt;\n\n&lt;!-- 2. Use type( parameter data type.) --&gt;\n&lt;bean id=\"student\" class=\"Student\"&gt;\n    &lt;constructor-arg type=\"String\" value=\"Alamgir\"/&gt;\n    &lt;constructor-arg type=\"int\" value=\"12\"/&gt;\n&lt;/bean&gt;\n\n&lt;!-- 3. Use name(if compiled with parameter) (specify parameter name) --&gt;\n&lt;bean id=\"student\" class=\"Student\"&gt;\n    &lt;constructor-arg name=\"name\" value=\"Alamgir\"/&gt;\n    &lt;constructor-arg name=\"id\" value=\"12\"/&gt;\n&lt;/bean&gt;\n</code></pre>"},{"location":"spring-framework/7-di-xml/#3-bean-wiring","title":"3. Bean Wiring","text":"<ul> <li>Connecting one bean to another bean.</li> <li>Done by using the ref attribute.</li> </ul> <pre><code>&lt;bean id=\"addressBean\" class=\"Address\"&gt;&lt;/bean&gt;\n&lt;bean id=\"student\" class=\"Student\"&gt;\n    &lt;property name=\"address\" ref=\"addressBean\"/&gt;\n&lt;/bean&gt;\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"spring-framework/7-di-xml/#am","title":"4. Autowiring Modes","text":"<p>Allows to automatically inject dependent beans without explicitly using the <code>ref</code> attribute.</p>  Four configuration values for `autowire` attribute: <ol> <li> <p>no : manual wiring only, no automatic injection.</p> </li> <li> <p>byType</p> <ul> <li>Matches bean by class type.</li> <li>Uses setter injection by default.</li> <li>Constructor injection is not used unless explicitly with <code>@Autowired</code>.</li> <li>Setter required, Constructor not used.</li> <li>Bean ID not used.</li> </ul> <p>Situtation when:</p> <ul> <li>No bean of the type \u2192 throws <code>NoSuchBeanDefinitionException</code>.</li> <li>Exactly one bean of the type \u2192 injects successfully.</li> <li>More than one bean of the type \u2192 throws <code>NoUniqueBeanDefinitionException</code>.</li> </ul> </li> <li> <p>byName</p> <ul> <li>Matches property name with bean ID.</li> <li>Type doesn\u2019t matter.</li> <li>Setter required,, Constructor not used.</li> <li>Bean ID is used.</li> </ul> <p>Situtation when:</p> <ul> <li>No bean with matching name \u2192 throws <code>NoSuchBeanDefinitionException</code>.</li> <li>Exactly one bean with matching name \u2192 injects successfully.</li> <li>Duplicate bean names \u2192 Duplicate bean definition throws <code>BeanDefinitionStoreException</code>.</li> </ul> </li> <li> <p>constructor</p> <ul> <li>Matches constructor argument type with bean ID.</li> <li> <p>Works only with constructors.</p> <p>Situtation when:</p> </li> <li> <p>No bean of the type \u2192 <code>NoSuchBeanDefinitionException</code>.</p> </li> <li>Exactly one bean of the type \u2192 injects successfully.</li> <li>If more than one bean of type exist \u2192 tries to match constructor parameter name with bean ID.If found then <code>injects</code> otherwise throws <code>NoUniqueBeanDefinitionException</code>. </li> </ul> </li> </ol> Scenario <pre><code>    class Address {\n    private String name;\n    public Address() {}\n    public Address(String name){ this.name=name; }\n    public void setName(String name){ this.name=name; }\n    } \n\n    class Student {\n        private Address addressBean;\n        public Student() {}\n        public Student(Address addressBean){ this.addressBean=addressBean; }\n        public void setAddressBean(Address addressBean){ this.addressBean=addressBean; }\n    }\n</code></pre> byType <p>( property name addressBean is type of Address (Address in Student))</p> <pre><code>&lt;bean id=\"aBean\" class=\"Address\"&gt;\n    &lt;property name=\"name\" value=\"Alamgir\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"studentBean\" class=\"Student\" autowire=\"byType\"/&gt;\n</code></pre> byName <p>(property name addressBean = bean ID addressBean) <pre><code>&lt;bean id=\"addressBean\" class=\"Address\"&gt;\n    &lt;property name=\"name\" value=\"Alamgir\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"studentBean\" class=\"Student\" autowire=\"byName\"/&gt;\n</code></pre></p> constructor <pre><code>&lt;bean id=\"addressBean\" class=\"Address\"&gt;\n    &lt;property name=\"name\" value=\"Alamgir\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"studentBean\" class=\"Student\" autowire=\"constructor\"/&gt;\n</code></pre> <p>Steps:</p> <ul> <li>Finds the <code>Student(Address addressBean)</code> constructor.</li> <li>Looks for a bean of type <code>Address</code>.</li> <li>Injects it automatically.</li> </ul>"},{"location":"spring-framework/7-di-xml/#5-when-to-use-setter-and-constructor-injection","title":"5. When to Use Setter and Constructor Injection","text":"<p>Use Setter Injection when:</p> <ol> <li>Dependencies are optional (object can be created without them).</li> <li>To set partial/optional properties.</li> <li>Properties may change or override later (mutable).</li> <li>Easier config when many properties.</li> </ol> <p>Use Constructor Injection when:</p> <ol> <li>Dependencies are mandatory (object cannot exist without them).</li> <li>To set all/mandatory properties at once.</li> <li>Object should be immutable after creation.</li> <li>Ensures required dependencies at object creation time.</li> </ol> <p>\u2191 Back to top </p> <p>Github Code : Dependency Injection Basic : spring  Github Code : Autowiring : spring </p>"},{"location":"spring-framework/8-creating-bean-annotation/","title":"8. Creating Bean via Annotation","text":"Creating Bean via Annotation Creating Bean in two ways: <ol> <li><code>@Configuration</code> and <code>@Bean</code></li> <li><code>@ComponentScan</code> and <code>@Component</code></li> </ol>"},{"location":"spring-framework/8-creating-bean-annotation/#1-configuration-and-bean","title":"1. @Configuration and @Bean","text":"<ul> <li><code>@Configuration</code> \u2013 Marks a class as a source for bean definitions.</li> <li><code>@Bean</code> <ul> <li>Marks a method\u2019s that return object should be managed by the IoC container.</li> <li>Used at Method level.</li> <li>Return type should be Bean class type.</li> <li>Can configure value in bean object(otherwise use default values for properties). <ul> <li><code>@Bean</code>(name = {\"bean1\", \"alias1\", \"alias2\"})</li> </ul> </li> </ul> </li> </ul> <p>How It Works:</p> <ol> <li>Spring scans the <code>@Configuration</code> class.</li> <li>Methods annotated with <code>@Bean</code> are called.</li> <li>Return objects are registered as Spring beans.</li> <li>Dependencies can be wired by calling other <code>@Bean</code> methods or using <code>@Autowired</code>.</li> </ol> Example Code <pre><code>    public class Address{\n            private String email;\n            public void Address(){}\n            public void setEmail(String email){this.email=email;}\n    }\n\n    public class Student{\n            private String name;\n            public void Student(){}\n            public void setName(String name){this.name=name;}\n    }\n\n    @Configuration\n    public class AppConfig{\n            @Bean(\"student1\") \n            public Student getStudent1(){return new Student();} \n\n            @Bean\n            public Student getStudent2(){return new Student();} \n\n            @Bean(\"address1\")\n            public Student getAddress(){\n                Address address=new Address;\n                a.setEmail(\"a@gmail.com\");\n                return address;\n            }\n    }\n\n\n    class Test{\n            ApplicationContext container=AnnotationConfigApplicationContext(AppConfig.class); //create container object\n            Student s1=(Student)container.getBean(\"student1\");      //get the bean object\n            Student s2=(Student)container.getBean(\"getStudent2\");  //get the bean object\n            Address a1=(Address)container.getBean(\"address1\");     //get the bean object\n    }\n</code></pre> <p>what happend:</p> <ol> <li>Scans the <code>@Configuration</code> class.</li> <li>Methods annotated with <code>@Bean</code> are called(<code>getStudent1</code>,<code>getStudent2</code>,<code>getAddress</code>).</li> <li>Return objects(Address) are registered as Spring beans.</li> <li>spring container configure with bean id : <code>student1</code>,<code>getStudent2</code>,<code>address1</code></li> </ol> Rules for @Configuration and  @Bean <ol> <li>In Configuration class If a method is not annotated with <code>@Bean</code>, Spring will not execute it for bean creation. <pre><code>       @Configuration\n        public class AppConfig{\n            //not a bean. a Plain object ; not registered in Spring context\n            public Student getStudent(){return new Student();}  \n        }\n</code></pre></li> <li>If <code>@Bean</code> has no explicit ID:<ul> <li>Method is executed and Bean object created.</li> <li>Method name becomes the bean ID. <pre><code>        @Configuration\n        public class AppConfig{\n            @Bean //Bean id is getStudent\n            public Student getStudent(){return new Student();}  \n        }\n</code></pre></li> </ul> </li> <li> <p>If duplicate bean IDs exist: throw <code>BeanDefinitionOverrideException</code> <pre><code>        @Configuration\n        public class AppConfig{\n            @Bean(\"student\")\n            public Student getStudent(){return new Student();}  \n            @Bean(\"student\")\n            public Student getStudent(){return new Student();}  \n        }\n</code></pre></p> </li> <li> <p>Multiple Configuration class:</p> </li> </ol> Example Code <pre><code>    @Configuration\n        public class AppConfig1{\n            @Bean(\"student1\") \n            public Student getStudent1(){return new Student();} \n            @Bean(\"address1\")public Student getAddress(return new Address){ }\n        }\n\n    @Configuration\n        public class AppConfig2{\n            @Bean(\"student2\") \n            public Student getStudent1(){return new Student();} \n            @Bean(\"address2\")\n            public Student getAddress(return new Address){ }\n        }\n\n    class Test{\n            ApplicationContext container=AnnotationConfigApplicationContext(AppConfig1.class,AppConfig2.class); //create container object\n            Student s1=(Student)container.getBean(\"student1\");      //get the bean object\n            Address a1=(Address)container.getBean(\"address1\");      //get the bean object\n\n            Student s1=(Student)container.getBean(\"student2\");     //get the bean object\n            Address a1=(Address)container.getBean(\"address2\");     //get the bean object\n        }    \n</code></pre>"},{"location":"spring-framework/8-creating-bean-annotation/#2-component-and-componentscan","title":"2. @Component and @ComponentScan","text":"<p><code>@Component</code></p> <ul> <li>Generic stereotype annotation(auto-detect and register beans).</li> <li>Marks class as a Spring-managed bean.</li> <li>Works with component scanning ( / <code>@Component</code>Scan). <li>Must create Default Constructor otherwise throws <code>UnsatisfiedDependencyException</code> .</li> <li>Bean object created with deafult constructor execution.</li> <li>Can't configure value in bean object(always use default values for properties). </li> <li>Used as Class level.</li> <p>For <code>@Component</code> classes</p> <ul> <li>Only parameterized constructor :need default constructor or use <code>@Autowired</code> on the parameterized one.</li> <li>No constructor :  default constructor created automatically (Spring uses it).</li> <li>Both constructors : Spring uses default unless use <code>@Autowired</code> on the parameterized one.</li> </ul> <p><code>@ComponentScan</code></p> <ul> <li>Tells Spring where to scan for components (classes with <code>@Component</code>,<code>@Service</code>, etc.)</li> <li>Scan the Package and Sub-Package .</li> </ul> <p>Example</p> Example Code <pre><code>    package com.spring;\n    @Component\n    public class AddressClass{}\n\n    package com.spring.pkg;\n    @Component(\"myStudent\")\n    // `@Component`(value=\"myStudent\")\n    public class Student{}\n\n\n    @Configuration\n    @ComponentScan(\"com.spring\") // uses 'value' alias\n    @ComponentScan(basePackages = \"com.spring\")  // uses base Packages explicitly\n    @ComponentScan(basePackages = {\"com.spring\", \"com.demo\"}) // multiple packages\n    @ComponentScan(basePackageClasses = Student.class) // scan package where Student is\n    class AppConfig{\n\n    }\n\n\n    class Test{\n        ApplicationContext container = new AnnotationConfigApplicationContext(AppConfig.class);\n        Address a=(Address)container.getBean(\"addressClass\");   \n        Student s = container.getBean(\"myStudent\", Student.class);\n    }\n</code></pre> <p>what happend:</p> <ol> <li>spring loads AppConfig(beacuse of <code>@Configuration</code>).</li> <li>scans the package and sub-package using <code>@ComponentScan</code>.</li> <li>Finds classes annotated with <code>@Component</code>(Student,AddressClass).</li> <li>Creates instances of Student and AddressClass.</li> <li>Bean ID assignment:<ul> <li>for AddressClass = <code>addressClass</code> ; beacuse bean id is not specified ,class name taken as bean id (camel case)</li> <li>for Student = <code>myStudent</code></li> </ul> </li> </ol>"},{"location":"spring-framework/8-creating-bean-annotation/#3-question","title":"3. Question","text":"<p>How can we create a Spring bean for a userdefiend and predefined (third-party) class? Should we use <code>@Component</code>, <code>@Bean</code>, or both?</p> <ul> <li>user-Defiend Class : can use either <code>@Component</code> or <code>@Bean</code>.</li> <li> <p>Pre-Defined class : only <code>@Bean</code>  beacuse cannot add <code>@Component</code> (cannot modify the source code to add annotations)</p> <pre><code>@Configuration\npublic class AppConfig{\n    @Bean\n    public Date getDate(){return new Date();}\n}\n</code></pre> </li> </ul> <p>Key Points</p> <ol> <li><code>@Component</code>: one bean per class (unless  change the scope).</li> <li><code>@Bean</code> : can define multiple beans of the same class (different IDs).</li> </ol> <p></p> <p>\u2191 Back to top</p> <p>Github Code : Creating Bean: Spring Boot</p>"},{"location":"spring-framework/9-di-annotation/","title":"DI and Autowiring via Annotation/Java Based Configuration","text":""},{"location":"spring-framework/9-di-annotation/#intro","title":"Three main ways to inject dependencies via Annotation:","text":"<ol> <li>Field / Property Injection  </li> <li>Constructor Injection  </li> <li>Setter Injection  </li> </ol> What is Autowiring? <p>Autowiring is automatic injection of dependencies by Spring. Instead of manually linking beans in <code>XML</code> or <code>Java config</code>, Spring can detect and inject them automatically.</p> What is Field Injection? <p>Putting the <code>@Autowired</code> annotation directly on a class field, so Spring injects the dependency without using setters or constructors.</p>"},{"location":"spring-framework/9-di-annotation/#2-autowired-annotation","title":"2. @Autowired AnnotationQuestion","text":"<ul> <li>Tells Spring to automatically inject a bean into another bean,  </li> <li>letting the IoC container resolve and provide the dependency at runtime.  </li> <li>Injects only reference types (beans), not primitives or Strings.  </li> <li>can be applied to: Fields, Setter methods and Constructors.  </li> <li>No control of Programmer.  </li> </ul> @Autowired Resolution Rules  <ul> <li>Primary rule : <code>byType</code> </li> <li>If multiple beans of that type exist : Try <code>byName</code> resolution.  </li> <li>checks field name / parameter name with bean ID.  </li> <li> <p>If a match is found then bean is injected.  </p> </li> <li> <p>If still ambiguous : throws <code>NoUniqueBeanDefinitionException</code> (can fix with <code>@Qualifier</code> or <code>@Primary</code>)  </p> </li> </ul> Example Code <pre><code>      package com.spring;\n      @Component\n      public class Address{\n         public void Address(){}\n      }\n\n      package com.spring.pkg;\n      @Component(\"myStudent\")\n      public class Student{\n            @Autowired // Field Injection\n            public Address address;\n\n            public void Student(){}\n            public Address getAddress(){return address;  }\n      }\n\n\n      @Configuration\n      @ComponentScan(\"com.spring\") \n      class AppConfig{   \n      }\n\n\n      class Test{\n         ApplicationContext container = new AnnotationConfigApplicationContext(AppConfig.class);  \n         Student s = container.getBean(\"myStudent\", Student.class);\n      }\n</code></pre> How it works: <ol> <li>Spring scans the package.</li> <li>Finds Address and Student as <code>@Component</code> beans.</li> <li>Injects Address into Student\u2019s address field automatically.</li> </ol> <p>Given Dependency Type : <code>Address</code> Available beans: <code>address</code>, <code>address1</code></p> Case 1: Student : Address address <ol> <li>type = Address (two beans exist).</li> <li>Field name=<code>address</code> matches bean id <code>address</code></li> <li>DI success : injects <code>address</code></li> </ol> Case 2: Student : Address address1 <ol> <li>type = Address (two beans exist).</li> <li>Field name = <code>address1</code>  matches bean id <code>address1</code>.</li> <li>DI Success: injects <code>address1</code></li> </ol> Case 3: Student : Address xyz <ol> <li>type = <code>Address</code> (two beans exist).</li> <li>Field name = <code>xyz</code> but no matching bean id.</li> <li>DI Failed: throws <code>NoUniqueBeanDefinitionException</code></li> </ol>"},{"location":"spring-framework/9-di-annotation/#3-ambiguity-problem","title":"3. Ambiguity Problem","text":"<p>Plain Java : Ambiguity arises with overloaded constructors + null arguments.</p> <p>In Spring, if define multiple constructors, Spring doesn\u2019t know which constructor to use for injection, leading to an error.</p> <pre><code>@Component\nclass Student {\n   private String name;\n   private int age;\n   public Student(String name) {this.name = name; }\n   public Student(int age) {  this.age = age; }\n}\n</code></pre> <p>Spring cannot figure out whether to call Student(String) or Student(int) when creating the bean.</p>"},{"location":"spring-framework/9-di-annotation/#ways","title":"3.1 Ways to solve Ambiguity","text":"1. Mark the intended constructor with @Autowired <pre><code>@Component\nclass Student {\n   private String name;\n\n   @Autowired\n   public Student(String name) {this.name = name;} // Spring will use this\n   public Student(int age) { }  //spring Not used for Dependency Injection\n}\n</code></pre> 2. Use @Qualifier to tell Spring which bean to inject <ul> <li><code>@Qualifier</code> resolves conflicts(ambiguity) when multiple beans of the same type exist.</li> <li>Must match <code>bean id</code> or bean name exactly.</li> <li>used with <code>@Autowired</code> for constructor, setter, or field/property  injection.</li> <li>which bean id is quialified for DI process.</li> <li>Acts like <code>ref</code> attribute in XML perspective.</li> </ul> Example Code <pre><code>// Address Class\npackage com.spring;\n@Component(\"address1\")\npublic class Address{\npublic void Address(){}\n}\n\n//Student Class\npackage com.spring.pkg;\n@Component(\"myStudent\")\npublic class Student{\n\n   @Autowired \n   Qualifier(\"address2\")\n   public Address address;\n   public void Student(){}\n}\n\n//AppConfig Class\n@Configuration\n@ComponentScan(\"com.spring\") \nclass AppConfig{ \n\n   @Bean\n   public Address address2(){\n      return Address();\n   } \n   @Bean\n   public Address address3(){\n      return Address();\n   } \n}\n</code></pre> 3. Use @Primary Annotation <ul> <li>Marks a bean as default when multiple beans of same type exist.</li> <li>Works with <code>@Autowired</code> to avoid ambiguity.</li> <li>Can be used on a class (<code>@Component</code>) or a method (<code>@Bean</code>).</li> </ul> <pre><code>@Bean\n@Primary\npublic String defaultName() {\n   return \"Default Name\";\n}\n</code></pre> Remember: <ul> <li>Avoid overloaded constructors in Spring-managed beans.</li> <li>Best practice: define only one constructor for injection.</li> </ul>"},{"location":"spring-framework/9-di-annotation/#4-di-with-interface-and-implements","title":"4. DI with Interface and Implements","text":"Scenario <pre><code>class Vehicle(){\n    public String type();\n}\n\n\n@Component\nclass Car implements Vehicle(){\n    @override\n    public String type(){return \"type :Car\"}\n}\n\n@Component\nclass Bike implements Vehicle(){\n    @override\n    public String type(){return \"type is Bike\"}\n}\n\n@Component\nclass Garage(){\n\n    @Qualifier(\"bike\")\n    @Autowired\n    private Vehicle vehicle;\n}\n</code></pre> What happens? <ol> <li>spring scan for beans.</li> <li>creates bean object(<code>car</code>,<code>bike</code>,<code>garage</code>).</li> <li> <p>Garage class need a Vehicle</p> <ul> <li><code>@Autowired</code> + <code>@Qualifier(\"bike\")</code> tells Spring:Don\u2019t just pick any Vehicle, inject the bean with name bike. So Spring injects the Bike object.</li> </ul> </li> <li> <p>Result </p> <ul> <li>Inside Garage, the vehicle field refers to the Bike bean.</li> <li>Calling <code>vehicle.type()</code> will return: <code>type is Bike</code></li> </ul> </li> </ol>"},{"location":"spring-framework/9-di-annotation/#5-priority-between-qualifier-and-primary","title":"5. Priority between @Qualifier and @Primary","text":"<ul> <li>@Qualifier : Has higher priority (explicit match).</li> <li>@Primary : Used only if no @Qualifier is specified.</li> <li>If neither is used : <code>NoUniqueBeanDefinitionException</code> when multiple beans exist.</li> </ul> <p>So @Qualifier overrides @Primary.</p>"},{"location":"spring-framework/9-di-annotation/#6-relation-among-autowired-qualifier-and-primary","title":"6. Relation among @Autowired ,@Qualifier and @Primary","text":"<ul> <li><code>@Autowired</code> \u2192 performs injection.</li> <li>If multiple beans \u2192 Spring looks for<code>@Qualifier</code>.</li> <li>If no <code>@Qualifier</code> \u2192 Spring falls back to <code>@Primary</code>.</li> <li>If neither \u2192 <code>NoUniqueBeanDefinitionException</code>. \u2191 Back to top</li> </ul> <p>Github Code : DI via Annotation : Spring Boot</p>"}]}